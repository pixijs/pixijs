import EventEmitter from 'eventemitter3';
import { Bounds } from '../../../../scene/container/bounds/Bounds';
import { uid } from '../../../../utils/data/uid';
import { Attribute, type AttributeOption, ensureIsAttribute, type IAttribute } from './Attribute';
import { DrawInstanceParameters } from './DrawInstanceParameters';
import { ensureIsBuffer, isBufferOption } from './utils/ensureIsBuffer';
import { getAttributeInfoFromFormat } from './utils/getAttributeInfoFromFormat';
import { getGeometryBounds } from './utils/getGeometryBounds';

import type { Buffer } from '../buffer/Buffer';
import type { Topology } from './const';
import type { BufferOption } from './utils/ensureIsBuffer';

export type IndexBufferArray = Uint16Array | Uint32Array;

/**
 * the interface that describes the structure of the geometry
 * @memberof rendering
 */
export interface GeometryDescriptor
{
    /** an optional label to easily identify the geometry */
    label?: string;
    /** the attributes that make up the geometry */
    attributes?: Record<string, AttributeOption>;
    vertexBuffer?: BufferOption;
    /** optional index buffer for this geometry */
    indexBuffer?: BufferOption;
    /** the topology of the geometry, defaults to 'triangle-list' */
    topology?: Topology;
    proto?: Geometry;

    /** Number of instances */
    instanceCount?: number;
    /** Instancing parameters */
    instanceParams?: DrawInstanceParameters
}

/**
 * A Geometry is a low-level object that represents the structure of 2D shapes in terms of vertices and attributes.
 * It's a crucial component for rendering as it describes the shape and format of the data that will go through the shaders.
 * Essentially, a Geometry object holds the data you'd send to a GPU buffer.
 *
 * A geometry is basically made of two components:
 * <br>
 * <b>Attributes</b>: These are essentially arrays that define properties of the vertices like position, color,
 * texture coordinates, etc. They map directly to attributes in your vertex shaders.
 * <br>
 * <b>Indices</b>: An optional array that describes how the vertices are connected.
 * If not provided, vertices will be interpreted in the sequence they're given.
 * @example
 *
 * const geometry = new Geometry({
 *   attributes: {
 *     aPosition: [ // add some positions
 *       0, 0,
 *       0, 100,
 *       100, 100,
 *       100,   0,
 *     ],
 *     aUv: [ // add some uvs
 *       0, 0,
 *       0, 1,
 *       1, 1,
 *       1, 0,
 *     ]
 *   }
 * });
 * @memberof rendering
 * @class
 */
export class Geometry extends EventEmitter<{
    update: Geometry,
    destroy: Geometry,
}>
{
    /** prototype of geometry, holds the same attributes, bufferStride, and instanceParams */
    public proto: Geometry;
    /** The topology of the geometry. */
    public topology: Topology;
    /** The unique id of the geometry. */
    public readonly uid: number = uid('geometry');
    /** A record of the attributes of the geometry. */
    public readonly attributes: Record<string, Attribute>;
    /** The buffers that the attributes use. First is some vertex buffer. Last is index buffer. */
    public readonly buffers: Buffer[] = [];
    /** strides of all vertex buffers, vertex per byte */
    public bufferStride: Array<number>;
    /** First vertex buffer */
    public vertexBuffer: Buffer = null;
    /** The index buffer of the geometry */
    public indexBuffer: Buffer;
    /** Whether the geometry is instanced. Calculated by constuctor parameters and by attribute definitions */
    public instanceParams: DrawInstanceParameters;

    /**
     * the layout key will be generated by WebGPU all geometries that have the same structure
     * will have the same layout key. This is used to cache the pipeline layout
     * @internal
     * @ignore
     */
    public _layoutKey = 0;

    /** the instance count of the geometry to draw */
    public instanceCount = 1;

    private readonly _bounds: Bounds = new Bounds();
    private _boundsDirty = true;
    private _attributesFinalized = false;

    /**
     * Create a new instance of a geometry
     * @param options - The options for the geometry.
     */
    constructor(options: GeometryDescriptor = { attributes: {} })
    {
        super();

        this.instanceCount = options.instanceCount || 1;

        if (options.vertexBuffer)
        {
            this.vertexBuffer = ensureIsBuffer(options.vertexBuffer, false);
        }
        if (options.indexBuffer)
        {
            this.indexBuffer = ensureIsBuffer(options.indexBuffer, true);
        }

        const proto = options.proto;

        if (options.proto)
        {
            this.buffers = proto.buffers.slice(0);
            this.attributes = proto.attributes;
            this._initFromProto(options);
        }
        else
        {
            this.buffers = [];
            this.attributes = {};
            this._initFromAttributes(options);
        }
    }

    private _initFromProto(options: GeometryDescriptor)
    {
        const proto = this.proto = options.proto;

        this.bufferStride = proto.bufferStride;
        this.topology = options.topology || proto.topology;
        this.instanceParams = proto.instanceParams;
        this.instanceCount = options.instanceCount ?? 1;

        if (!proto._attributesFinalized)
        {
            proto._finalizeAttributes();
        }
        this._attributesFinalized = true;

        if (this.vertexBuffer)
        {
            this.buffers[0] = this.vertexBuffer;
        }
        if (this.indexBuffer)
        {
            const ind = this.buffers.indexOf(proto.indexBuffer);

            if (ind >= 0)
            {
                this.buffers[ind] = this.indexBuffer;
            }
            else
            {
                this.buffers.push(this.indexBuffer);
            }
        }
        for (const i in options.attributes)
        {
            const attr = options.attributes[i];

            if (this.attributes[i])
            {
                const bufInd = this.attributes[i].bufferIndex;

                if (isBufferOption(attr))
                {
                    this.buffers[bufInd] = ensureIsBuffer(attr as BufferOption, false);
                }
                else
                {
                    const buf = (attr as IAttribute).buffer;

                    if (buf)
                    {
                        this.buffers[bufInd] = buf;
                    }
                }
            }
            else
            {
                throw new Error(`Geometry: attribute does not exist in prototype geom ${i}`);
            }
        }
    }

    private _initFromAttributes(options: GeometryDescriptor)
    {
        this.bufferStride = [];
        this.topology = options.topology || 'triangle-list';
        this.instanceParams = options.instanceParams;

        if (this.vertexBuffer)
        {
            this.buffers[0] = this.vertexBuffer;
            this.bufferStride[0] = 0;
        }

        for (const i in options.attributes)
        {
            this.addAttribute(i, options.attributes[i]);
        }

        if (this.indexBuffer)
        {
            this.buffers.push(this.indexBuffer);
        }
    }

    /** Ensures that attribute list is final and will not change */
    public ensureAttributes()
    {
        if (!this._attributesFinalized)
        {
            this._finalizeAttributes();
        }
    }

    private _finalizeAttributes()
    {
        if (this._attributesFinalized)
        {
            return;
        }

        this._attributesFinalized = true;

        const attributes = this.attributes;
        const bufferStride = this.bufferStride;
        const inst = this.instanceParams;

        if (this.vertexBuffer)
        {
            if (this.instanceParams)
            {
                if (inst.vertexCount)
                {
                    this.bufferStride[0] = (inst.instanced ? inst.vertexCount : 1) * 4;
                }
                else
                {
                    inst.strideFloats = this.bufferStride[0] / 4;
                }
            }
        }

        for (const j in attributes)
        {
            const attribute = attributes[j];

            if (attribute.stride === undefined)
            {
                attribute.stride = bufferStride[attribute.bufferIndex];
            }
        }
    }

    protected onBufferUpdate(): void
    {
        this._boundsDirty = true;
        this.emit('update', this);
    }

    /**
     * Returns the requested attribute.
     * @param id - The name of the attribute required
     * @returns - The attribute requested.
     */
    public getAttribute(id: string): Attribute
    {
        return this.attributes[id];
    }

    /**
     * Returns the index buffer
     * @returns - The index buffer.
     */
    public getIndex(): Buffer
    {
        return this.indexBuffer;
    }

    /**
     * Returns the requested buffer.
     * @param id - The name of the buffer required.
     * @returns - The buffer requested.
     */
    public getBuffer(id: string): Buffer
    {
        return this.getAttribute(id).buffer;
    }

    /**
     * Used to figure out how many vertices there are in this geometry
     * @returns the number of vertices in the geometry
     */
    public getSize(): number
    {
        for (const i in this.attributes)
        {
            const attribute = this.attributes[i];
            const buffer = attribute.buffer;

            // TODO use SIZE again like v7..
            return (buffer.data as any).length / (this.bufferStride[attribute.bufferIndex] / 4);
        }

        return 0;
    }

    /**
     * Adds an attribute to the geometry.
     * @param name - The name of the attribute to add.
     * @param attributeOption - The attribute option to add.
     */
    public addAttribute(name: string, attributeOption: AttributeOption): void
    {
        if (this._attributesFinalized)
        {
            throw new Error('Geometry: cannot add attribute to geometry with prototype or finalized');
        }

        const defaultInstanced = this.instanceParams?.instanced ?? false;
        const attr = new Attribute(ensureIsAttribute(attributeOption, this.vertexBuffer, defaultInstanced));

        let bufferIndex = attr.bufferIndex = this.buffers.indexOf(attr.buffer);
        const bufferStride = this.bufferStride;

        if (bufferIndex === -1)
        {
            bufferIndex = attr.bufferIndex = this.buffers.length;
            this.buffers.push(attr.buffer);
            bufferStride[bufferIndex] = 0;

            // two events here - one for a resize (new buffer change)
            // and one for an update (existing buffer change)
            attr.buffer.on('update', this.onBufferUpdate, this);
            attr.buffer.on('change', this.onBufferUpdate, this);
        }

        if (attr.instance)
        {
            if (!this.instanceParams)
            {
                this.instanceParams = new DrawInstanceParameters({ instanced: true });
            }
            else
            {
                this.instanceParams.instanced = true;
            }
        }

        if (attr.format === undefined)
        {
            throw new Error(`Geometry: cannot add attribute "${name}" without vertex format`);
        }

        const attrInfo = getAttributeInfoFromFormat(attr.format);

        if (attr.offset === undefined)
        {
            attr.offset = bufferStride[bufferIndex];
        }

        bufferStride[bufferIndex] = Math.max(bufferStride[bufferIndex], attr.offset + attrInfo.stride);

        this.attributes[name] = attr;
    }

    /**
     * Adds an index buffer to the geometry.
     * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.
     */
    public addIndex(indexBuffer: BufferOption): void
    {
        if (this.proto)
        {
            // can set index buffer only if current one is from prototype
            if (this.indexBuffer !== this.proto.indexBuffer)
            {
                throw new Error('Geometry: cannot add second index buffer to prototype that didnt have it');
            }

            const ind = this.buffers.indexOf(this.indexBuffer);

            this.indexBuffer = ensureIsBuffer(indexBuffer, true);
            this.buffers[ind] = this.indexBuffer;
        }

        this.indexBuffer = ensureIsBuffer(indexBuffer, true);
        this.buffers.push(this.indexBuffer);
    }

    /** Returns the bounds of the geometry. */
    get bounds(): Bounds
    {
        if (!this._boundsDirty) return this._bounds;

        this._boundsDirty = false;

        return getGeometryBounds(this, 'aPosition', this._bounds);
    }

    /**
     * destroys the geometry.
     * @param destroyBuffers - destroy the buffers associated with this geometry
     */
    public destroy(destroyBuffers = false): void
    {
        this.emit('destroy', this);

        this.removeAllListeners();

        if (destroyBuffers)
        {
            if (this.proto)
            {
                for (let i = 0; i < this.buffers.length; i++)
                {
                    if (this.buffers[i] !== this.proto.buffers[i])
                    {
                        this.buffers[i].destroy();
                    }
                }
            }
            else
            {
                this.buffers.forEach((buffer) => buffer.destroy());
            }
        }

        (this.attributes as null) = null;
        (this.buffers as null) = null;
        (this.indexBuffer as null) = null;
        (this._bounds as null) = null;
        (this.bufferStride as null) = null;
        this.instanceParams = null;
    }
}
