import { ExtensionType } from '../../../../extensions/Extensions';
import { unsafeEvalSupported } from '../../../../utils/unsafeEvalSupported';
import { generateUniformsSync } from './program/generateUniformsSync';

import type { ExtensionMetadata } from '../../../../extensions/Extensions';
import type { UniformGroup } from '../../shared/shader/UniformGroup';
import type { UniformsSyncCallback } from '../../shared/shader/utils/createUniformBufferSync';
import type { ISystem } from '../../shared/system/ISystem';
import type { GlRenderingContext } from '../context/GlRenderingContext';
import type { WebGLRenderer } from '../WebGLRenderer';
import type { GlProgram } from './GlProgram';

/**
 * System plugin to the renderer to manage shaders.
 * @memberof PIXI
 */
export class GlUniformGroupSystem implements ISystem
{
    /** @ignore */
    static extension: ExtensionMetadata = {
        type: [
            ExtensionType.WebGLRendererSystem,
        ],
        name: 'uniformGroup',
    };

    /**
     * The current WebGL rendering context.
     * @member {WebGLRenderingContext}
     */
    protected gl: GlRenderingContext;

    public destroyed = false;

    /** Cache to holds the generated functions. Stored against UniformObjects unique signature. */
    private cache: Record<string, UniformsSyncCallback> = {};
    private renderer: WebGLRenderer;

    private uniformGroupSyncHash: Record<string, Record<string, UniformsSyncCallback>> = {};

    /** @param renderer - The renderer this System works for. */
    constructor(renderer: WebGLRenderer)
    {
        this.renderer = renderer;

        // Validation check that this environment support `new Function`
        this.systemCheck();

        this.gl = null;

        this.cache = {};
    }

    /**
     * Overrideable function by `@pixi/unsafe-eval` to silence
     * throwing an error if platform doesn't support unsafe-evals.
     * @private
     */
    private systemCheck(): void
    {
        if (!unsafeEvalSupported())
        {
            throw new Error('Current environment does not allow unsafe-eval, '
                + 'please use @pixi/unsafe-eval module to enable support.');
        }
    }

    protected contextChange(gl: GlRenderingContext): void
    {
        this.gl = gl;
    }

    /**
     * Uploads the uniforms values to the currently bound shader.
     * @param group - the uniforms values that be applied to the current shader
     * @param program
     * @param syncData
     * @param syncData.textureCount
     */
    updateUniformGroup(group: UniformGroup, program: GlProgram, syncData: {textureCount: number}): void
    {
        const programData = this.renderer.shader.getProgramData(program);

        if (!group.isStatic || group.dirtyId !== programData.uniformDirtyGroups[group.uid])
        {
            programData.uniformDirtyGroups[group.uid] = group.dirtyId;

            const syncFunc = this.getUniformSyncFunction(group, program);

            syncFunc(programData.uniformData, group.uniforms, this.renderer, syncData);
        }
    }

    /**
     * Overrideable by the @pixi/unsafe-eval package to use static syncUniforms instead.
     * @param group
     * @param program
     */
    getUniformSyncFunction(group: UniformGroup, program: GlProgram): UniformsSyncCallback
    {
        return this.uniformGroupSyncHash[group.signature]?.[program.key]
        || this.createUniformSyncFunction(group, program);
    }

    createUniformSyncFunction(group: UniformGroup, program: GlProgram): UniformsSyncCallback
    {
        const uniformGroupSyncHash = this.uniformGroupSyncHash[group.signature]
         || (this.uniformGroupSyncHash[group.signature] = {});

        const id = this.getSignature(group, program.uniformData, 'u');

        if (!this.cache[id])
        {
            this.cache[id] = generateUniformsSync(group, program.uniformData);
        }

        uniformGroupSyncHash[program.key] = this.cache[id];

        return uniformGroupSyncHash[program.key];
    }

    /**
     * Takes a uniform group and data and generates a unique signature for them.
     * @param group - The uniform group to get signature of
     * @param group.uniforms
     * @param uniformData - Uniform information generated by the shader
     * @param preFix
     * @returns Unique signature of the uniform group
     */
    private getSignature(group: UniformGroup, uniformData: Record<string, any>, preFix: string): string
    {
        const uniforms = group.uniforms;

        const strings = [`${preFix}-`];

        for (const i in uniforms)
        {
            strings.push(i);

            if (uniformData[i])
            {
                strings.push(uniformData[i].type);
            }
        }

        return strings.join('-');
    }

    /** Destroys this System and removes all its textures. */
    destroy(): void
    {
        this.renderer = null;
        // TODO implement destroy method for ShaderSystem
        this.destroyed = true;
    }
}
