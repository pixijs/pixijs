{"version":3,"sources":["../../../src/core/geometry/Geometry.js"],"names":["byteSizeMap","UID","map","Float32Array","Uint32Array","Int32Array","Uint8Array","Uint16Array","Geometry","buffers","attributes","indexBuffer","glVertexArrayObjects","id","instanced","instanceCount","_size","addAttribute","buffer","size","normalised","type","stride","start","instance","Error","data","Array","ids","split","length","i","bufferIndex","indexOf","push","getAttribute","addIndex","index","getIndex","interleave","arrays","sizes","interleavedBuffer","attribute","destroy","getSize","clone","geometry","slice","attrib","normalized","merge","geometries","geometryOut","offsets","j","set","offset","offset2","bufferIndexToCount","indexBufferData"],"mappings":"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","file":"Geometry.js","sourcesContent":["import Attribute from './Attribute';\nimport Buffer from './Buffer';\nimport interleaveTypedArrays from '../utils/interleaveTypedArrays';\nimport getBufferType from '../utils/getBufferType';\n\nconst byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };\nlet UID = 0;\n\n/* eslint-disable object-shorthand */\nconst map = {\n    Float32Array: Float32Array,\n    Uint32Array: Uint32Array,\n    Int32Array: Int32Array,\n    Uint8Array: Uint8Array,\n    Uint16Array: Uint16Array,\n};\n\n/* eslint-disable max-len */\n\n/**\n * The Geometry represents a model. It consists of two components:\n * GeometryStyle - The structure of the model such as the attributes layout\n * GeometryData - the data of the model - this consits of buffers.\n *\n * This can include anything from positions, uvs, normals, colors etc..\n *\n * Geometry can be defined without passing in a style or data if required (thats how I prefer!)\n *\n * ```js\n * let geometry = new PIXI.mesh.Geometry();\n *\n * geometry.addAttribute('positions', [0, 0, 100, 0, 100, 100, 0, 100], 2);\n * geometry.addAttribute('uvs', [0,0,1,0,1,1,0,1],2)\n * geometry.addIndex([0,1,2,1,3,2])\n *\n * ```\n * @class\n * @memberof PIXI.mesh.Geometry\n */\nexport default class Geometry\n{\n    /**\n     * @param {array} buffers  an array of buffers. optional.\n     * @param {object} attributes of the geometry, optional structure of the attributes layout\n     */\n    constructor(buffers, attributes)\n    {\n        this.buffers = buffers || [];\n\n        this.indexBuffer = null;\n\n        this.attributes = attributes || {};\n\n        /**\n         * A map of renderer IDs to webgl VAOs\n         *\n         * @private\n         * @type {Array<VertexArrayObject>}\n         */\n        this.glVertexArrayObjects = {};\n\n        this.id = UID++;\n\n        this.instanced = false;\n\n        this.instanceCount = 1;\n\n        this._size = null;\n    }\n\n    /**\n    *\n    * Adds an attribute to the geometry\n    *\n    * @param {String} id - the name of the attribute (matching up to a shader)\n    * @param {PIXI.mesh.Buffer} [buffer] the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.\n    * @param {Number} [size=0] the size of the attribute. If you hava 2 floats per vertex (eg position x and y) this would be 2\n    * @param {Boolean} [normalised=false] should the data be normalised.\n    * @param {Number} [type=PIXI.TYPES.FLOAT] what type of numbe is the attribute. Check {PIXI.TYPES} to see the ones available\n    * @param {Number} [stride=0] How far apart (in floats) the start of each value is. (used for interleaving data)\n    * @param {Number} [start=0] How far into the array to start reading values (used for interleaving data)\n    *\n    * @return {PIXI.mesh.Geometry} returns self, useful for chaining.\n    */\n    addAttribute(id, buffer, size, normalised = false, type, stride, start, instance = false)\n    {\n        if (!buffer)\n        {\n            throw new Error('You must pass a buffer when creating an attribute');\n        }\n\n        // check if this is a buffer!\n        if (!buffer.data)\n        {\n            // its an array!\n            if (buffer instanceof Array)\n            {\n                buffer = new Float32Array(buffer);\n            }\n\n            buffer = new Buffer(buffer);\n        }\n\n        const ids = id.split('|');\n\n        if (ids.length > 1)\n        {\n            for (let i = 0; i < ids.length; i++)\n            {\n                this.addAttribute(ids[i], buffer, size, normalised, type);\n            }\n\n            return this;\n        }\n\n        let bufferIndex = this.buffers.indexOf(buffer);\n\n        if (bufferIndex === -1)\n        {\n            this.buffers.push(buffer);\n            bufferIndex = this.buffers.length - 1;\n        }\n\n        this.attributes[id] = new Attribute(bufferIndex, size, normalised, type, stride, start, instance);\n\n        // assuming that if there is instanced data then this will be drawn with instancing!\n        this.instanced = this.instanced || instance;\n\n        return this;\n    }\n\n    /**\n     * returns the requested attribute\n     *\n     * @param {String} id  the name of the attribute required\n     * @return {PIXI.mesh.Attribute} the attribute requested.\n     */\n    getAttribute(id)\n    {\n        return this.buffers[this.attributes[id].buffer];\n    }\n\n    /**\n    *\n    * Adds an index buffer to the geometry\n    * The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, â€¦). There is only ONE index buffer.\n    *\n    * @param {PIXI.mesh.Buffer} [buffer] the buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.\n    * @return {PIXI.mesh.Geometry} returns self, useful for chaining.\n    */\n    addIndex(buffer)\n    {\n        if (!buffer.data)\n        {\n            // its an array!\n            if (buffer instanceof Array)\n            {\n                buffer = new Uint16Array(buffer);\n            }\n\n            buffer = new Buffer(buffer);\n        }\n\n        buffer.index = true;\n        this.indexBuffer = buffer;\n\n        if (this.buffers.indexOf(buffer) === -1)\n        {\n            this.buffers.push(buffer);\n        }\n\n        return this;\n    }\n\n    /**\n     * returns the index buffer\n     *\n     * @return {PIXI.mesh.Buffer} the index buffer.\n     */\n    getIndex()\n    {\n        return this.indexBuffer;\n    }\n\n    /**\n     * this function modifies the structure so that all current attributes become interleaved into a single buffer\n     * This can be useful if your model remains static as it offers a little performance boost\n     *\n     * @return {PIXI.mesh.Geometry} returns self, useful for chaining.\n     */\n    interleave()\n    {\n        // a simple check to see if buffers are already interleaved..\n        if (this.buffers.length === 1 || (this.buffers.length === 2 && this.indexBuffer)) return this;\n\n        // assume already that no buffers are interleaved\n        const arrays = [];\n        const sizes = [];\n        const interleavedBuffer = new Buffer();\n        let i;\n\n        for (i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n\n            const buffer = this.buffers[attribute.buffer];\n\n            arrays.push(buffer.data);\n\n            sizes.push((attribute.size * byteSizeMap[attribute.type]) / 4);\n\n            attribute.buffer = 0;\n        }\n\n        interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);\n\n        for (i = 0; i < this.buffers.length; i++)\n        {\n            if (this.buffers[i] !== this.indexBuffer)\n            {\n                this.buffers[i].destroy();\n            }\n        }\n\n        this.buffers = [interleavedBuffer];\n\n        if (this.indexBuffer)\n        {\n            this.buffers.push(this.indexBuffer);\n        }\n\n        return this;\n    }\n\n    getSize()\n    {\n        for (const i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n            const buffer = this.buffers[attribute.buffer];\n\n            return buffer.data.length / ((attribute.stride / 4) || attribute.size);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Destroys the geometry.\n     */\n    destroy()\n    {\n        for (let i = 0; i < this.glVertexArrayObjects.length; i++)\n        {\n            this.glVertexArrayObjects[i].destroy();\n        }\n\n        this.glVertexArrayObjects = null;\n\n        for (let i = 0; i < this.buffers.length; i++)\n        {\n            this.buffers[i].destroy();\n        }\n\n        this.buffers = null;\n        this.indexBuffer.destroy();\n\n        this.attributes = null;\n    }\n\n    /**\n     * returns a clone of the geometry\n     *\n     * @returns {PIXI.mesh.Geometry} a new clone of this geometry\n     */\n    clone()\n    {\n        const geometry = new Geometry();\n\n        for (let i = 0; i < this.buffers.length; i++)\n        {\n            geometry.buffers[i] = new Buffer(this.buffers[i].data.slice());\n        }\n\n        for (const i in this.attributes)\n        {\n            const attrib = this.attributes[i];\n\n            geometry.attributes[i] = new Attribute(\n                attrib.buffer,\n                attrib.size,\n                attrib.normalized,\n                attrib.type,\n                attrib.stride,\n                attrib.start,\n                attrib.instance\n            );\n        }\n\n        if (this.indexBuffer)\n        {\n            geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];\n            geometry.indexBuffer.index = true;\n        }\n\n        return geometry;\n    }\n\n    /**\n     * merges an array of geometries into a new single one\n     * geometry attribute styles must match for this operation to work\n     *\n     * @param {array|PIXI.mesh.Geometry} geometries array of geometries to merge\n     * @returns {PIXI.mesh.Geometry} shiney new geometry\n     */\n    static merge(geometries)\n    {\n        // todo add a geometry check!\n        // also a size check.. cant be too big!]\n\n        const geometryOut = new Geometry();\n\n        const arrays = [];\n        const sizes = [];\n        const offsets = [];\n\n        let geometry;\n\n        // pass one.. get sizes..\n        for (let i = 0; i < geometries.length; i++)\n        {\n            geometry = geometries[i];\n\n            for (let j = 0; j < geometry.buffers.length; j++)\n            {\n                sizes[j] = sizes[j] || 0;\n                sizes[j] += geometry.buffers[j].data.length;\n                offsets[j] = 0;\n            }\n        }\n\n        // build the correct size arrays..\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            // TODO types!\n            arrays[i] = new map[getBufferType(geometry.buffers[i].data)](sizes[i]);\n            geometryOut.buffers[i] = new Buffer(arrays[i]);\n        }\n\n        // pass to set data..\n        for (let i = 0; i < geometries.length; i++)\n        {\n            geometry = geometries[i];\n\n            for (let j = 0; j < geometry.buffers.length; j++)\n            {\n                arrays[j].set(geometry.buffers[j].data, offsets[j]);\n                offsets[j] += geometry.buffers[j].data.length;\n            }\n        }\n\n        geometryOut.attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];\n            geometryOut.indexBuffer.index = true;\n\n            let offset = 0;\n            let stride = 0;\n            let offset2 = 0;\n            let bufferIndexToCount = 0;\n\n            // get a buffer\n            for (let i = 0; i < geometry.buffers.length; i++)\n            {\n                if (geometry.buffers[i] !== geometry.indexBuffer)\n                {\n                    bufferIndexToCount = i;\n                    break;\n                }\n            }\n\n            // figure out the stride of one buffer..\n            for (const i in geometry.attributes)\n            {\n                const attribute = geometry.attributes[i];\n\n                if ((attribute.buffer | 0) === bufferIndexToCount)\n                {\n                    stride += ((attribute.size * byteSizeMap[attribute.type]) / 4);\n                }\n            }\n\n            // time to off set all indexes..\n            for (let i = 0; i < geometries.length; i++)\n            {\n                const indexBufferData = geometries[i].indexBuffer.data;\n\n                for (let j = 0; j < indexBufferData.length; j++)\n                {\n                    geometryOut.indexBuffer.data[j + offset2] += offset;\n                }\n\n                offset += geometry.buffers[bufferIndexToCount].data.length / (stride);\n                offset2 += indexBufferData.length;\n            }\n        }\n\n        return geometryOut;\n    }\n}\n"]}