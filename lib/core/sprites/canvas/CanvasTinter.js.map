{"version":3,"sources":["../../../../src/core/sprites/canvas/CanvasTinter.js"],"names":["CanvasTinter","getTintedTexture","sprite","color","texture","roundColor","stringColor","toString","substr","tintCache","canvas","document","createElement","tintMethod","convertTintToImage","tintImage","Image","src","toDataURL","tintWithMultiply","context","getContext","crop","_frame","clone","resolution","baseTexture","x","y","width","height","Math","ceil","fillStyle","fillRect","globalCompositeOperation","drawImage","source","tintWithOverlay","tintWithPerPixel","rgbValues","r","g","b","pixelData","getImageData","pixels","data","i","length","putImageData","step","cacheStepsPerColorChannel","min","canUseMultiply"],"mappings":";;;;AAAA;;AACA;;;;;;AAEA;;;;;;AAMA,IAAMA,eAAe;AACjB;;;;;;;;AAQAC,sBAAkB,0BAACC,MAAD,EAASC,KAAT,EAClB;AACI,YAAMC,UAAUF,OAAOE,OAAvB;;AAEAD,gBAAQH,aAAaK,UAAb,CAAwBF,KAAxB,CAAR;;AAEA,YAAMG,oBAAkB,WAAS,CAACH,QAAQ,CAAT,EAAYI,QAAZ,CAAqB,EAArB,CAAT,EAAqCC,MAArC,CAA4C,CAAC,CAA7C,CAAxB;;AAEAJ,gBAAQK,SAAR,GAAoBL,QAAQK,SAAR,IAAqB,EAAzC;;AAEA,YAAIL,QAAQK,SAAR,CAAkBH,WAAlB,CAAJ,EACA;AACI,mBAAOF,QAAQK,SAAR,CAAkBH,WAAlB,CAAP;AACH;;AAED;AACA,YAAMI,SAASV,aAAaU,MAAb,IAAuBC,SAASC,aAAT,CAAuB,QAAvB,CAAtC;;AAEA;AACAZ,qBAAaa,UAAb,CAAwBT,OAAxB,EAAiCD,KAAjC,EAAwCO,MAAxC;;AAEA,YAAIV,aAAac,kBAAjB,EACA;AACI;AACA,gBAAMC,YAAY,IAAIC,KAAJ,EAAlB;;AAEAD,sBAAUE,GAAV,GAAgBP,OAAOQ,SAAP,EAAhB;;AAEAd,oBAAQK,SAAR,CAAkBH,WAAlB,IAAiCS,SAAjC;AACH,SARD,MAUA;AACIX,oBAAQK,SAAR,CAAkBH,WAAlB,IAAiCI,MAAjC;AACA;AACAV,yBAAaU,MAAb,GAAsB,IAAtB;AACH;;AAED,eAAOA,MAAP;AACH,KA/CgB;;AAiDjB;;;;;;;;AAQAS,sBAAkB,0BAACf,OAAD,EAAUD,KAAV,EAAiBO,MAAjB,EAClB;AACI,YAAMU,UAAUV,OAAOW,UAAP,CAAkB,IAAlB,CAAhB;AACA,YAAMC,OAAOlB,QAAQmB,MAAR,CAAeC,KAAf,EAAb;AACA,YAAMC,aAAarB,QAAQsB,WAAR,CAAoBD,UAAvC;;AAEAH,aAAKK,CAAL,IAAUF,UAAV;AACAH,aAAKM,CAAL,IAAUH,UAAV;AACAH,aAAKO,KAAL,IAAcJ,UAAd;AACAH,aAAKQ,MAAL,IAAeL,UAAf;;AAEAf,eAAOmB,KAAP,GAAeE,KAAKC,IAAL,CAAUV,KAAKO,KAAf,CAAf;AACAnB,eAAOoB,MAAP,GAAgBC,KAAKC,IAAL,CAAUV,KAAKQ,MAAf,CAAhB;;AAEAV,gBAAQa,SAAR,SAAwB,WAAS,CAAC9B,QAAQ,CAAT,EAAYI,QAAZ,CAAqB,EAArB,CAAT,EAAqCC,MAArC,CAA4C,CAAC,CAA7C,CAAxB;;AAEAY,gBAAQc,QAAR,CAAiB,CAAjB,EAAoB,CAApB,EAAuBZ,KAAKO,KAA5B,EAAmCP,KAAKQ,MAAxC;;AAEAV,gBAAQe,wBAAR,GAAmC,UAAnC;;AAEAf,gBAAQgB,SAAR,CACIhC,QAAQsB,WAAR,CAAoBW,MADxB,EAEIf,KAAKK,CAFT,EAGIL,KAAKM,CAHT,EAIIN,KAAKO,KAJT,EAKIP,KAAKQ,MALT,EAMI,CANJ,EAOI,CAPJ,EAQIR,KAAKO,KART,EASIP,KAAKQ,MATT;;AAYAV,gBAAQe,wBAAR,GAAmC,kBAAnC;;AAEAf,gBAAQgB,SAAR,CACIhC,QAAQsB,WAAR,CAAoBW,MADxB,EAEIf,KAAKK,CAFT,EAGIL,KAAKM,CAHT,EAIIN,KAAKO,KAJT,EAKIP,KAAKQ,MALT,EAMI,CANJ,EAOI,CAPJ,EAQIR,KAAKO,KART,EASIP,KAAKQ,MATT;AAWH,KAtGgB;;AAwGjB;;;;;;;;AAQAQ,mBAhHiB,2BAgHDlC,OAhHC,EAgHQD,KAhHR,EAgHeO,MAhHf,EAiHjB;AACI,YAAMU,UAAUV,OAAOW,UAAP,CAAkB,IAAlB,CAAhB;AACA,YAAMC,OAAOlB,QAAQmB,MAAR,CAAeC,KAAf,EAAb;AACA,YAAMC,aAAarB,QAAQsB,WAAR,CAAoBD,UAAvC;;AAEAH,aAAKK,CAAL,IAAUF,UAAV;AACAH,aAAKM,CAAL,IAAUH,UAAV;AACAH,aAAKO,KAAL,IAAcJ,UAAd;AACAH,aAAKQ,MAAL,IAAeL,UAAf;;AAEAf,eAAOmB,KAAP,GAAeE,KAAKC,IAAL,CAAUV,KAAKO,KAAf,CAAf;AACAnB,eAAOoB,MAAP,GAAgBC,KAAKC,IAAL,CAAUV,KAAKQ,MAAf,CAAhB;;AAEAV,gBAAQe,wBAAR,GAAmC,MAAnC;AACAf,gBAAQa,SAAR,SAAwB,WAAS,CAAC9B,QAAQ,CAAT,EAAYI,QAAZ,CAAqB,EAArB,CAAT,EAAqCC,MAArC,CAA4C,CAAC,CAA7C,CAAxB;AACAY,gBAAQc,QAAR,CAAiB,CAAjB,EAAoB,CAApB,EAAuBZ,KAAKO,KAA5B,EAAmCP,KAAKQ,MAAxC;;AAEAV,gBAAQe,wBAAR,GAAmC,kBAAnC;AACAf,gBAAQgB,SAAR,CACIhC,QAAQsB,WAAR,CAAoBW,MADxB,EAEIf,KAAKK,CAFT,EAGIL,KAAKM,CAHT,EAIIN,KAAKO,KAJT,EAKIP,KAAKQ,MALT,EAMI,CANJ,EAOI,CAPJ,EAQIR,KAAKO,KART,EASIP,KAAKQ,MATT;;AAYA;AACH,KAhJgB;;;AAkJjB;;;;;;;;AAQAS,sBAAkB,0BAACnC,OAAD,EAAUD,KAAV,EAAiBO,MAAjB,EAClB;AACI,YAAMU,UAAUV,OAAOW,UAAP,CAAkB,IAAlB,CAAhB;AACA,YAAMC,OAAOlB,QAAQmB,MAAR,CAAeC,KAAf,EAAb;AACA,YAAMC,aAAarB,QAAQsB,WAAR,CAAoBD,UAAvC;;AAEAH,aAAKK,CAAL,IAAUF,UAAV;AACAH,aAAKM,CAAL,IAAUH,UAAV;AACAH,aAAKO,KAAL,IAAcJ,UAAd;AACAH,aAAKQ,MAAL,IAAeL,UAAf;;AAEAf,eAAOmB,KAAP,GAAeE,KAAKC,IAAL,CAAUV,KAAKO,KAAf,CAAf;AACAnB,eAAOoB,MAAP,GAAgBC,KAAKC,IAAL,CAAUV,KAAKQ,MAAf,CAAhB;;AAEAV,gBAAQe,wBAAR,GAAmC,MAAnC;AACAf,gBAAQgB,SAAR,CACIhC,QAAQsB,WAAR,CAAoBW,MADxB,EAEIf,KAAKK,CAFT,EAGIL,KAAKM,CAHT,EAIIN,KAAKO,KAJT,EAKIP,KAAKQ,MALT,EAMI,CANJ,EAOI,CAPJ,EAQIR,KAAKO,KART,EASIP,KAAKQ,MATT;;AAYA,YAAMU,YAAY,oBAAQrC,KAAR,CAAlB;AACA,YAAMsC,IAAID,UAAU,CAAV,CAAV;AACA,YAAME,IAAIF,UAAU,CAAV,CAAV;AACA,YAAMG,IAAIH,UAAU,CAAV,CAAV;;AAEA,YAAMI,YAAYxB,QAAQyB,YAAR,CAAqB,CAArB,EAAwB,CAAxB,EAA2BvB,KAAKO,KAAhC,EAAuCP,KAAKQ,MAA5C,CAAlB;;AAEA,YAAMgB,SAASF,UAAUG,IAAzB;;AAEA,aAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIF,OAAOG,MAA3B,EAAmCD,KAAK,CAAxC,EACA;AACIF,mBAAOE,IAAI,CAAX,KAAiBP,CAAjB;AACAK,mBAAOE,IAAI,CAAX,KAAiBN,CAAjB;AACAI,mBAAOE,IAAI,CAAX,KAAiBL,CAAjB;AACH;;AAEDvB,gBAAQ8B,YAAR,CAAqBN,SAArB,EAAgC,CAAhC,EAAmC,CAAnC;AACH,KAtMgB;;AAwMjB;;;;;;;AAOAvC,gBAAY,oBAACF,KAAD,EACZ;AACI,YAAMgD,OAAOnD,aAAaoD,yBAA1B;;AAEA,YAAMZ,YAAY,oBAAQrC,KAAR,CAAlB;;AAEAqC,kBAAU,CAAV,IAAeT,KAAKsB,GAAL,CAAS,GAAT,EAAeb,UAAU,CAAV,IAAeW,IAAhB,GAAwBA,IAAtC,CAAf;AACAX,kBAAU,CAAV,IAAeT,KAAKsB,GAAL,CAAS,GAAT,EAAeb,UAAU,CAAV,IAAeW,IAAhB,GAAwBA,IAAtC,CAAf;AACAX,kBAAU,CAAV,IAAeT,KAAKsB,GAAL,CAAS,GAAT,EAAeb,UAAU,CAAV,IAAeW,IAAhB,GAAwBA,IAAtC,CAAf;;AAEA,eAAO,oBAAQX,SAAR,CAAP;AACH,KA1NgB;;AA4NjB;;;;;;AAMAY,+BAA2B,CAlOV;;AAoOjB;;;;;;AAMAtC,wBAAoB,KA1OH;;AA4OjB;;;;;;AAMAwC,oBAAgB,0CAlPC;;AAoPjB;;;;;;AAMAzC,gBAAY;AA1PK,CAArB;;AA6PAb,aAAaa,UAAb,GAA0Bb,aAAasD,cAAb,GAA8BtD,aAAamB,gBAA3C,GAA8DnB,aAAauC,gBAArG;;AAEA;;;;;;;;;;kBAUevC,Y","file":"CanvasTinter.js","sourcesContent":["import { hex2rgb, rgb2hex } from '../../utils';\nimport canUseNewCanvasBlendModes from '../../renderers/canvas/utils/canUseNewCanvasBlendModes';\n\n/**\n * Utility methods for Sprite/Texture tinting.\n *\n * @class\n * @memberof PIXI\n */\nconst CanvasTinter = {\n    /**\n     * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Sprite} sprite - the sprite to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @return {HTMLCanvasElement} The tinted canvas\n     */\n    getTintedTexture: (sprite, color) =>\n    {\n        const texture = sprite.texture;\n\n        color = CanvasTinter.roundColor(color);\n\n        const stringColor = `#${(`00000${(color | 0).toString(16)}`).substr(-6)}`;\n\n        texture.tintCache = texture.tintCache || {};\n\n        if (texture.tintCache[stringColor])\n        {\n            return texture.tintCache[stringColor];\n        }\n\n        // clone texture..\n        const canvas = CanvasTinter.canvas || document.createElement('canvas');\n\n        // CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);\n        CanvasTinter.tintMethod(texture, color, canvas);\n\n        if (CanvasTinter.convertTintToImage)\n        {\n            // is this better?\n            const tintImage = new Image();\n\n            tintImage.src = canvas.toDataURL();\n\n            texture.tintCache[stringColor] = tintImage;\n        }\n        else\n        {\n            texture.tintCache[stringColor] = canvas;\n            // if we are not converting the texture to an image then we need to lose the reference to the canvas\n            CanvasTinter.canvas = null;\n        }\n\n        return canvas;\n    },\n\n    /**\n     * Tint a texture using the 'multiply' operation.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */\n    tintWithMultiply: (texture, color, canvas) =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture._frame.clone();\n        const resolution = texture.baseTexture.resolution;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        canvas.width = Math.ceil(crop.width);\n        canvas.height = Math.ceil(crop.height);\n\n        context.fillStyle = `#${(`00000${(color | 0).toString(16)}`).substr(-6)}`;\n\n        context.fillRect(0, 0, crop.width, crop.height);\n\n        context.globalCompositeOperation = 'multiply';\n\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        context.globalCompositeOperation = 'destination-atop';\n\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n    },\n\n    /**\n     * Tint a texture using the 'overlay' operation.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */\n    tintWithOverlay(texture, color, canvas)\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture._frame.clone();\n        const resolution = texture.baseTexture.resolution;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        canvas.width = Math.ceil(crop.width);\n        canvas.height = Math.ceil(crop.height);\n\n        context.globalCompositeOperation = 'copy';\n        context.fillStyle = `#${(`00000${(color | 0).toString(16)}`).substr(-6)}`;\n        context.fillRect(0, 0, crop.width, crop.height);\n\n        context.globalCompositeOperation = 'destination-atop';\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        // context.globalCompositeOperation = 'copy';\n    },\n\n    /**\n     * Tint a texture pixel per pixel.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */\n    tintWithPerPixel: (texture, color, canvas) =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture._frame.clone();\n        const resolution = texture.baseTexture.resolution;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        canvas.width = Math.ceil(crop.width);\n        canvas.height = Math.ceil(crop.height);\n\n        context.globalCompositeOperation = 'copy';\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        const rgbValues = hex2rgb(color);\n        const r = rgbValues[0];\n        const g = rgbValues[1];\n        const b = rgbValues[2];\n\n        const pixelData = context.getImageData(0, 0, crop.width, crop.height);\n\n        const pixels = pixelData.data;\n\n        for (let i = 0; i < pixels.length; i += 4)\n        {\n            pixels[i + 0] *= r;\n            pixels[i + 1] *= g;\n            pixels[i + 2] *= b;\n        }\n\n        context.putImageData(pixelData, 0, 0);\n    },\n\n    /**\n     * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {number} color - the color to round, should be a hex color\n     * @return {number} The rounded color.\n     */\n    roundColor: (color) =>\n    {\n        const step = CanvasTinter.cacheStepsPerColorChannel;\n\n        const rgbValues = hex2rgb(color);\n\n        rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);\n        rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);\n        rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);\n\n        return rgb2hex(rgbValues);\n    },\n\n    /**\n     * Number of steps which will be used as a cap when rounding colors.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {number}\n     */\n    cacheStepsPerColorChannel: 8,\n\n    /**\n     * Tint cache boolean flag.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {boolean}\n     */\n    convertTintToImage: false,\n\n    /**\n     * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {boolean}\n     */\n    canUseMultiply: canUseNewCanvasBlendModes(),\n\n    /**\n     * The tinting method that will be used.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {tintMethodFunctionType}\n     */\n    tintMethod: 0,\n};\n\nCanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply : CanvasTinter.tintWithPerPixel;\n\n/**\n * The tintMethod type.\n *\n * @memberof PIXI.CanvasTinter\n * @callback tintMethodFunctionType\n * @param texture {PIXI.Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\n\nexport default CanvasTinter;\n"]}