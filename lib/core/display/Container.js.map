{"version":3,"sources":["../../../src/core/display/Container.js"],"names":["Container","children","onChildrenChange","addChild","child","argumentsLength","arguments","length","i","parent","removeChild","transform","_parentID","push","_boundsID","emit","addChildAt","index","Error","splice","swapChildren","child2","index1","getChildIndex","index2","indexOf","setChildIndex","currentIndex","getChildAt","removeChildAt","removeChildren","beginIndex","endIndex","begin","end","range","removed","RangeError","updateTransform","worldAlpha","alpha","j","visible","calculateBounds","_bounds","clear","_calculateBounds","renderable","_mask","addBoundsMask","filterArea","addBoundsArea","addBounds","_lastBoundsID","renderWebGL","renderer","_filters","renderAdvancedWebGL","_renderWebGL","flush","filters","mask","_enabledFilters","enabled","filterManager","pushFilter","maskManager","pushMask","popMask","popFilter","_renderCanvas","renderCanvas","destroy","options","destroyChildren","oldChildren","scale","x","getLocalBounds","width","value","_width","y","height","_height","prototype","containerUpdateTransform"],"mappings":"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","file":"Container.js","sourcesContent":["import { removeItems } from '../utils';\nimport DisplayObject from './DisplayObject';\n\n/**\n * A Container represents a collection of display objects.\n * It is the base class of all display objects that act as a container for other objects.\n *\n *```js\n * let container = new PIXI.Container();\n * container.addChild(sprite);\n * ```\n *\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI\n */\nexport default class Container extends DisplayObject\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        super();\n\n        /**\n         * The array of children of this container.\n         *\n         * @member {PIXI.DisplayObject[]}\n         * @readonly\n         */\n        this.children = [];\n    }\n\n    /**\n     * Overridable method that can be used by Container subclasses whenever the children array is modified\n     *\n     * @private\n     */\n    onChildrenChange()\n    {\n        /* empty */\n    }\n\n    /**\n     * Adds one or more children to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n     *\n     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container\n     * @return {PIXI.DisplayObject} The first child that was added.\n     */\n    addChild(child)\n    {\n        const argumentsLength = arguments.length;\n\n        // if there is only one argument we can bypass looping through the them\n        if (argumentsLength > 1)\n        {\n            // loop through the arguments property and add all children\n            // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes\n            for (let i = 0; i < argumentsLength; i++)\n            {\n                this.addChild(arguments[i]);\n            }\n        }\n        else\n        {\n            // if the child has a parent then lets remove it as Pixi objects can only exist in one place\n            if (child.parent)\n            {\n                child.parent.removeChild(child);\n            }\n\n            child.parent = this;\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n\n            this.children.push(child);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(this.children.length - 1);\n            child.emit('added', this);\n        }\n\n        return child;\n    }\n\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n     *\n     * @param {PIXI.DisplayObject} child - The child to add\n     * @param {number} index - The index to place the child in\n     * @return {PIXI.DisplayObject} The child that was added.\n     */\n    addChildAt(child, index)\n    {\n        if (index < 0 || index > this.children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        this.children.splice(index, 0, child);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('added', this);\n\n        return child;\n    }\n\n    /**\n     * Swaps the position of 2 Display Objects within this container.\n     *\n     * @param {PIXI.DisplayObject} child - First display object to swap\n     * @param {PIXI.DisplayObject} child2 - Second display object to swap\n     */\n    swapChildren(child, child2)\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2;\n        this.children[index2] = child;\n        this.onChildrenChange(index1 < index2 ? index1 : index2);\n    }\n\n    /**\n     * Returns the index position of a child DisplayObject instance\n     *\n     * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify\n     * @return {number} The index position of the child display object to identify\n     */\n    getChildIndex(child)\n    {\n        const index = this.children.indexOf(child);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied DisplayObject must be a child of the caller');\n        }\n\n        return index;\n    }\n\n    /**\n     * Changes the position of an existing child in the display object container\n     *\n     * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number\n     * @param {number} index - The resulting index number for the child display object\n     */\n    setChildIndex(child, index)\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error('The supplied index is out of bounds');\n        }\n\n        const currentIndex = this.getChildIndex(child);\n\n        removeItems(this.children, currentIndex, 1); // remove from old position\n        this.children.splice(index, 0, child); // add at new position\n\n        this.onChildrenChange(index);\n    }\n\n    /**\n     * Returns the child at the specified index\n     *\n     * @param {number} index - The index to get the child at\n     * @return {PIXI.DisplayObject} The child at the given index, if any.\n     */\n    getChildAt(index)\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index];\n    }\n\n    /**\n     * Removes one or more children from the container.\n     *\n     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove\n     * @return {PIXI.DisplayObject} The first child that was removed.\n     */\n    removeChild(child)\n    {\n        const argumentsLength = arguments.length;\n\n        // if there is only one argument we can bypass looping through the them\n        if (argumentsLength > 1)\n        {\n            // loop through the arguments property and add all children\n            // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes\n            for (let i = 0; i < argumentsLength; i++)\n            {\n                this.removeChild(arguments[i]);\n            }\n        }\n        else\n        {\n            const index = this.children.indexOf(child);\n\n            if (index === -1) return null;\n\n            child.parent = null;\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n            removeItems(this.children, index, 1);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(index);\n            child.emit('removed', this);\n        }\n\n        return child;\n    }\n\n    /**\n     * Removes a child from the specified index position.\n     *\n     * @param {number} index - The index to get the child from\n     * @return {PIXI.DisplayObject} The child that was removed.\n     */\n    removeChildAt(index)\n    {\n        const child = this.getChildAt(index);\n\n        // ensure child transform will be recalculated..\n        child.parent = null;\n        child.transform._parentID = -1;\n        removeItems(this.children, index, 1);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('removed', this);\n\n        return child;\n    }\n\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     *\n     * @param {number} [beginIndex=0] - The beginning position.\n     * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.\n     * @returns {DisplayObject[]} List of removed children\n     */\n    removeChildren(beginIndex = 0, endIndex)\n    {\n        const begin = beginIndex;\n        const end = typeof endIndex === 'number' ? endIndex : this.children.length;\n        const range = end - begin;\n        let removed;\n\n        if (range > 0 && range <= end)\n        {\n            removed = this.children.splice(begin, range);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].parent = null;\n                if (removed[i].transform)\n                {\n                    removed[i].transform._parentID = -1;\n                }\n            }\n\n            this._boundsID++;\n\n            this.onChildrenChange(beginIndex);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].emit('removed', this);\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return [];\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    }\n\n    /**\n     * Updates the transform on all children of this container for rendering\n     */\n    updateTransform()\n    {\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n\n        // TODO: check render flags, how to process stuff here\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n\n            if (child.visible)\n            {\n                child.updateTransform();\n            }\n        }\n    }\n\n    /**\n     * Recalculates the bounds of the container.\n     *\n     */\n    calculateBounds()\n    {\n        this._bounds.clear();\n\n        this._calculateBounds();\n\n        for (let i = 0; i < this.children.length; i++)\n        {\n            const child = this.children[i];\n\n            if (!child.visible || !child.renderable)\n            {\n                continue;\n            }\n\n            child.calculateBounds();\n\n            // TODO: filter+mask, need to mask both somehow\n            if (child._mask)\n            {\n                child._mask.calculateBounds();\n                this._bounds.addBoundsMask(child._bounds, child._mask._bounds);\n            }\n            else if (child.filterArea)\n            {\n                this._bounds.addBoundsArea(child._bounds, child.filterArea);\n            }\n            else\n            {\n                this._bounds.addBounds(child._bounds);\n            }\n        }\n\n        this._lastBoundsID = this._boundsID;\n    }\n\n    /**\n     * Recalculates the bounds of the object. Override this to\n     * calculate the bounds of the specific object (not including children).\n     *\n     */\n    _calculateBounds()\n    {\n        // FILL IN//\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    renderWebGL(renderer)\n    {\n        // if the object is not visible or the alpha is 0 then no need to render this element\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        // do a quick check to see if this element has a mask or a filter.\n        if (this._mask || this._filters)\n        {\n            this.renderAdvancedWebGL(renderer);\n        }\n        else\n        {\n            this._renderWebGL(renderer);\n\n            // simple render children!\n            for (let i = 0, j = this.children.length; i < j; ++i)\n            {\n                this.children[i].renderWebGL(renderer);\n            }\n        }\n    }\n\n    /**\n     * Render the object using the WebGL renderer and advanced features.\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    renderAdvancedWebGL(renderer)\n    {\n        renderer.flush();\n\n        const filters = this._filters;\n        const mask = this._mask;\n\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (filters)\n        {\n            if (!this._enabledFilters)\n            {\n                this._enabledFilters = [];\n            }\n\n            this._enabledFilters.length = 0;\n\n            for (let i = 0; i < filters.length; i++)\n            {\n                if (filters[i].enabled)\n                {\n                    this._enabledFilters.push(filters[i]);\n                }\n            }\n\n            if (this._enabledFilters.length)\n            {\n                renderer.filterManager.pushFilter(this, this._enabledFilters);\n            }\n        }\n\n        if (mask)\n        {\n            renderer.maskManager.pushMask(this, this._mask);\n        }\n\n        // add this object to the batch, only rendered if it has a texture.\n        this._renderWebGL(renderer);\n\n        // now loop through the children and make sure they get rendered\n        for (let i = 0, j = this.children.length; i < j; i++)\n        {\n            this.children[i].renderWebGL(renderer);\n        }\n\n        renderer.flush();\n\n        if (mask)\n        {\n            renderer.maskManager.popMask(this, this._mask);\n        }\n\n        if (filters && this._enabledFilters && this._enabledFilters.length)\n        {\n            renderer.filterManager.popFilter();\n        }\n    }\n\n    /**\n     * To be overridden by the subclasses.\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    _renderWebGL(renderer) // eslint-disable-line no-unused-vars\n    {\n        // this is where content itself gets rendered...\n    }\n\n    /**\n     * To be overridden by the subclass\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    _renderCanvas(renderer) // eslint-disable-line no-unused-vars\n    {\n        // this is where content itself gets rendered...\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    renderCanvas(renderer)\n    {\n        // if not visible or the alpha is 0 then no need to render this\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        if (this._mask)\n        {\n            renderer.maskManager.pushMask(this._mask);\n        }\n\n        this._renderCanvas(renderer);\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            this.children[i].renderCanvas(renderer);\n        }\n\n        if (this._mask)\n        {\n            renderer.maskManager.popMask(renderer);\n        }\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy();\n\n        const destroyChildren = typeof options === 'boolean' ? options : options && options.children;\n\n        const oldChildren = this.removeChildren(0, this.children.length);\n\n        if (destroyChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n    }\n\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        return this.scale.x * this.getLocalBounds().width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        const width = this.getLocalBounds().width;\n\n        if (width !== 0)\n        {\n            this.scale.x = value / width;\n        }\n        else\n        {\n            this.scale.x = 1;\n        }\n\n        this._width = value;\n    }\n\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        return this.scale.y * this.getLocalBounds().height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        const height = this.getLocalBounds().height;\n\n        if (height !== 0)\n        {\n            this.scale.y = value / height;\n        }\n        else\n        {\n            this.scale.y = 1;\n        }\n\n        this._height = value;\n    }\n}\n\n// performance increase to avoid using call.. (10x faster)\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\n"]}