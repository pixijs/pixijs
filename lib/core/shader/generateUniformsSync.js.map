{"version":3,"sources":["../../../src/core/shader/generateUniformsSync.js"],"names":["generateUniformsSync","GLSL_TO_SINGLE_SETTERS_CACHED","float","vec2","vec3","vec4","int","ivec2","ivec3","ivec4","bool","bvec2","bvec3","bvec4","mat2","mat3","mat4","sampler2D","samplerCube","sampler2DArray","GLSL_TO_ARRAY_SETTERS","group","uniformData","textureCount","func","i","uniforms","data","type","size","isArray","a","undefined","x","templateType","template","replace","Function"],"mappings":"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","file":"generateUniformsSync.js","sourcesContent":["// cv = CachedValue\n// v = value\n// ud = uniformData\n// uv = uniformValue\n// l = loaction\nconst GLSL_TO_SINGLE_SETTERS_CACHED = {\n\n    float: `\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }`,\n\n    vec2: `\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }`,\n\n    vec3: `\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }`,\n\n    vec4:     'gl.uniform4f(location, v[0], v[1], v[2], v[3])',\n\n    int:      'gl.uniform1i(location, v)',\n    ivec2:    'gl.uniform2i(location, v[0], v[1])',\n    ivec3:    'gl.uniform3i(location, v[0], v[1], v[2])',\n    ivec4:    'gl.uniform4i(location, v[0], v[1], v[2], v[3])',\n\n    bool:     'gl.uniform1i(location, v)',\n    bvec2:    'gl.uniform2i(location, v[0], v[1])',\n    bvec3:    'gl.uniform3i(location, v[0], v[1], v[2])',\n    bvec4:    'gl.uniform4i(location, v[0], v[1], v[2], v[3])',\n\n    mat2:     'gl.uniformMatrix2fv(location, false, v)',\n    mat3:     'gl.uniformMatrix3fv(location, false, v)',\n    mat4:     'gl.uniformMatrix4fv(location, false, v)',\n\n    sampler2D:      'gl.uniform1i(location, v)',\n    samplerCube:    'gl.uniform1i(location, v)',\n    sampler2DArray: 'gl.uniform1i(location, v)',\n};\n\nconst GLSL_TO_ARRAY_SETTERS = {\n\n    float:    `gl.uniform1fv(location, v)`,\n\n    vec2:     `gl.uniform2fv(location, v)`,\n    vec3:     `gl.uniform3fv(location, v)`,\n    vec4:     'gl.uniform4fv(location, v)',\n\n    mat4:     'gl.uniformMatrix4fv(location, false, v)',\n    mat3:     'gl.uniformMatrix3fv(location, false, v)',\n    mat2:     'gl.uniformMatrix2fv(location, false, v)',\n\n    int:      'gl.uniform1iv(location, v)',\n    ivec2:    'gl.uniform2iv(location, v)',\n    ivec3:    'gl.uniform3iv(location, v)',\n    ivec4:    'gl.uniform4iv(location, v)',\n\n    bool:     'gl.uniform1iv(location, v)',\n    bvec2:    'gl.uniform2iv(location, v)',\n    bvec3:    'gl.uniform3iv(location, v)',\n    bvec4:    'gl.uniform4iv(location, v)',\n\n    sampler2D:      'gl.uniform1iv(location, v)',\n    samplerCube:    'gl.uniform1iv(location, v)',\n    sampler2DArray: 'gl.uniform1iv(location, v)',\n};\n\nexport default function generateUniformsSync(group, uniformData)\n{\n    let textureCount = 0;\n    let func = `var v = null;\n    var cv = null\n    var gl = renderer.gl`;\n\n    for (const i in group.uniforms)\n    {\n        const data = uniformData[i];\n\n        if (!data)\n        {\n            if (group.uniforms[i].group)\n            {\n                func += `\n                    renderer.shader.syncUniformGroup(uv.${i});\n                `;\n            }\n\n            continue;\n        }\n\n        // TODO && uniformData[i].value !== 0 <-- do we still need this?\n        if (data.type === 'float' && data.size === 1)\n        {\n            func += `\n            if(uv.${i} !== ud.${i}.value)\n            {\n                ud.${i}.value = uv.${i}\n                gl.uniform1f(ud.${i}.location, uv.${i})\n            }\\n`;\n        }\n        /* eslint-disable max-len */\n        else if ((data.type === 'sampler2D' || data.type === 'samplerCube' || data.type === 'sampler2DArray') && data.size === 1 && !data.isArray)\n        /* eslint-disable max-len */\n        {\n            func += `\n            renderer.texture.bind(uv.${i}, ${textureCount});\n\n            if(ud.${i}.value !== ${textureCount})\n            {\n                ud.${i}.value = ${textureCount};\n                gl.uniform1i(ud.${i}.location, ${textureCount});\\n; // eslint-disable-line max-len\n            }\\n`;\n\n            textureCount++;\n        }\n        else if (data.type === 'mat3' && data.size === 1)\n        {\n            if (group.uniforms[i].a !== undefined)\n            {\n                // TODO and some smart caching dirty ids here!\n                func += `\n                gl.uniformMatrix3fv(ud.${i}.location, false, uv.${i}.toArray(true));\n                \\n`;\n            }\n            else\n            {\n                func += `\n                gl.uniformMatrix3fv(ud.${i}.location, false, uv.${i});\n                \\n`;\n            }\n        }\n        else if (data.type === 'vec2' && data.size === 1)\n        {\n            // TODO - do we need both here?\n            // maybe we can get away with only using points?\n            if (group.uniforms[i].x !== undefined)\n            {\n                func += `\n                cv = ud.${i}.value;\n                v = uv.${i};\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud.${i}.location, v.x, v.y);\n                }\\n`;\n            }\n            else\n            {\n                func += `\n                cv = ud.${i}.value;\n                v = uv.${i};\n\n                    if(cv[0] !== v[0] || cv[1] !== v[1])\n                    {\n                        cv[0] = v[0];\n                        cv[1] = v[1];\n                        gl.uniform2f(ud.${i}.location, v[0], v[1]);\n                    }\n                }\\n`;\n            }\n        }\n        else\n        {\n            const templateType = (data.size === 1) ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;\n\n            const template =  templateType[data.type].replace('location', `ud.${i}.location`);\n\n            func += `\n            cv = ud.${i}.value;\n            v = uv.${i};\n            ${template};\\n`;\n        }\n    }\n\n    // console.log(' --------------- ')\n    // console.log(func);\n\n    return new Function('ud', 'uv', 'renderer', func); // eslint-disable-line no-new-func\n}\n"]}