{"version":3,"sources":["../../../../src/core/renderers/webgl/WebGLRenderer.js"],"names":["CONTEXT_UID","WebGLRenderer","options","arg2","arg3","legacy","VertexArrayObject","FORCE_NATIVE","type","WEBGL","handleContextLost","bind","handleContextRestored","view","addEventListener","_contextOptions","alpha","transparent","antialias","premultipliedAlpha","stencil","preserveDrawingBuffer","_backgroundColorRgba","maskManager","stencilManager","emptyRenderer","currentRenderer","initPlugins","context","gl","createContext","state","renderingToScreen","boundTextures","_activeShader","_activeVao","_activeRenderTarget","_initContext","filterManager","drawModes","_nextTextureLocation","setBlendMode","isContextLost","getExtension","restoreContext","maxTextures","getParameter","MAX_TEXTURE_IMAGE_UNITS","Array","emptyTextures","textureManager","textureGC","resetToDefault","rootRenderTarget","width","height","resolution","clearColor","bindRenderTarget","emptyGLTexture","GLTexture","fromData","tempObj","_glTextures","i","empty","bindTexture","emit","resize","screen","render","displayObject","renderTexture","clear","transform","skipUpdateTransform","_lastObjectRendered","cacheParent","parent","_tempDisplayObjectParent","updateTransform","bindRenderTexture","start","undefined","clearBeforeRender","renderWebGL","flush","update","setObjectRenderer","objectRenderer","stop","screenWidth","screenHeight","prototype","call","activate","uniforms","projectionMatrix","toArray","blendMode","setTransform","matrix","clearRenderTexture","baseTexture","renderTarget","_glRenderTargets","updateTexture","unbindTexture","setFrame","frame","setMaskStack","stencilMaskStack","bindShader","shader","autoProject","texture","location","forceLocation","touched","count","length","glTexture","activeTexture","TEXTURE0","TEXTURE_2D","createVao","attribState","bindVao","vao","unbind","reset","event","preventDefault","removeAll","destroy","removeView","destroyPlugins","removeEventListener","uid","useProgram","loseContext","mixin"],"mappings":"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","file":"WebGLRenderer.js","sourcesContent":["import SystemRenderer from '../SystemRenderer';\nimport MaskManager from './managers/MaskManager';\nimport StencilManager from './managers/StencilManager';\nimport FilterManager from './managers/FilterManager';\nimport RenderTarget from './utils/RenderTarget';\nimport ObjectRenderer from './utils/ObjectRenderer';\nimport TextureManager from './TextureManager';\nimport BaseTexture from '../../textures/BaseTexture';\nimport TextureGarbageCollector from './TextureGarbageCollector';\nimport WebGLState from './WebGLState';\nimport mapWebGLDrawModesToPixi from './utils/mapWebGLDrawModesToPixi';\nimport validateContext from './utils/validateContext';\nimport { pluginTarget } from '../../utils';\nimport glCore from 'pixi-gl-core';\nimport { RENDERER_TYPE } from '../../const';\n\nlet CONTEXT_UID = 0;\n\n/**\n * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\n * So no need for Sprite Batches or Sprite Clouds.\n * Don't forget to add the view to your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n */\nexport default class WebGLRenderer extends SystemRenderer\n{\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     *\n     * @param {object} [options] - The optional renderer parameters\n     * @param {number} [options.width=800] - the width of the screen\n     * @param {number} [options.height=600] - the height of the screen\n     * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n     * @param {boolean} [options.transparent=false] - If the render view is transparent, default false\n     * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false\n     * @param {boolean} [options.antialias=false] - sets antialias. If not available natively then FXAA\n     *  antialiasing is used\n     * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.\n     *  FXAA is faster, but may not always look as great\n     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer.\n     *  The resolution of the renderer retina would be 2.\n     * @param {boolean} [options.clearBeforeRender=true] - This sets if the CanvasRenderer will clear\n     *  the canvas or not before the new render pass. If you wish to set this to false, you *must* set\n     *  preserveDrawingBuffer to `true`.\n     * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,\n     *  enable this if you need to call toDataUrl on the webgl context.\n     * @param {boolean} [options.roundPixels=false] - If true Pixi will Math.floor() x/y values when\n     *  rendering, stopping pixel interpolation.\n     * @param {boolean} [options.legacy=false] - If true Pixi will aim to ensure compatibility\n     * with older / less advanced devices. If you experiance unexplained flickering try setting this to true.\n     */\n    constructor(options, arg2, arg3)\n    {\n        super('WebGL', options, arg2, arg3);\n\n        this.legacy = this.options.legacy;\n\n        if (this.legacy)\n        {\n            glCore.VertexArrayObject.FORCE_NATIVE = true;\n        }\n\n        /**\n         * The type of this renderer as a standardised const\n         *\n         * @member {number}\n         * @see PIXI.RENDERER_TYPE\n         */\n        this.type = RENDERER_TYPE.WEBGL;\n\n        this.handleContextLost = this.handleContextLost.bind(this);\n        this.handleContextRestored = this.handleContextRestored.bind(this);\n\n        this.view.addEventListener('webglcontextlost', this.handleContextLost, false);\n        this.view.addEventListener('webglcontextrestored', this.handleContextRestored, false);\n\n        /**\n         * The options passed in to create a new webgl context.\n         *\n         * @member {object}\n         * @private\n         */\n        this._contextOptions = {\n            alpha: this.transparent,\n            antialias: this.options.antialias,\n            premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied',\n            stencil: true,\n            preserveDrawingBuffer: this.options.preserveDrawingBuffer,\n        };\n\n        this._backgroundColorRgba[3] = this.transparent ? 0 : 1;\n\n        /**\n         * Manages the masks using the stencil buffer.\n         *\n         * @member {PIXI.MaskManager}\n         */\n        this.maskManager = new MaskManager(this);\n\n        /**\n         * Manages the stencil buffer.\n         *\n         * @member {PIXI.StencilManager}\n         */\n        this.stencilManager = new StencilManager(this);\n\n        /**\n         * An empty renderer.\n         *\n         * @member {PIXI.ObjectRenderer}\n         */\n        this.emptyRenderer = new ObjectRenderer(this);\n\n        /**\n         * The currently active ObjectRenderer.\n         *\n         * @member {PIXI.ObjectRenderer}\n         */\n        this.currentRenderer = this.emptyRenderer;\n\n        this.initPlugins();\n\n        /**\n         * The current WebGL rendering context, it is created here\n         *\n         * @member {WebGLRenderingContext}\n         */\n        // initialize the context so it is ready for the managers.\n        if (this.options.context)\n        {\n            // checks to see if a context is valid..\n            validateContext(this.options.context);\n        }\n\n        this.gl = this.options.context || glCore.createContext(this.view, this._contextOptions);\n\n        this.CONTEXT_UID = CONTEXT_UID++;\n\n        /**\n         * The currently active ObjectRenderer.\n         *\n         * @member {PIXI.WebGLState}\n         */\n        this.state = new WebGLState(this.gl);\n\n        this.renderingToScreen = true;\n\n        /**\n         * Holds the current state of textures bound to the GPU.\n         * @type {Array}\n         */\n        this.boundTextures = null;\n\n        /**\n         * Holds the current shader\n         *\n         * @member {PIXI.Shader}\n         */\n        this._activeShader = null;\n\n        this._activeVao = null;\n\n        /**\n         * Holds the current render target\n         *\n         * @member {PIXI.RenderTarget}\n         */\n        this._activeRenderTarget = null;\n\n        this._initContext();\n\n        /**\n         * Manages the filters.\n         *\n         * @member {PIXI.FilterManager}\n         */\n        this.filterManager = new FilterManager(this);\n        // map some webGL blend and drawmodes..\n        this.drawModes = mapWebGLDrawModesToPixi(this.gl);\n\n        this._nextTextureLocation = 0;\n\n        this.setBlendMode(0);\n\n        /**\n         * Fired after rendering finishes.\n         *\n         * @event PIXI.WebGLRenderer#postrender\n         */\n\n        /**\n         * Fired before rendering starts.\n         *\n         * @event PIXI.WebGLRenderer#prerender\n         */\n\n        /**\n         * Fired when the WebGL context is set.\n         *\n         * @event PIXI.WebGLRenderer#context\n         * @param {WebGLRenderingContext} gl - WebGL context.\n         */\n    }\n\n    /**\n     * Creates the WebGL context\n     *\n     * @private\n     */\n    _initContext()\n    {\n        const gl = this.gl;\n\n        // restore a context if it was previously lost\n        if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context'))\n        {\n            gl.getExtension('WEBGL_lose_context').restoreContext();\n        }\n\n        const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n        this._activeShader = null;\n        this._activeVao = null;\n\n        this.boundTextures = new Array(maxTextures);\n        this.emptyTextures = new Array(maxTextures);\n\n        // create a texture manager...\n        this.textureManager = new TextureManager(this);\n        this.textureGC = new TextureGarbageCollector(this);\n\n        this.state.resetToDefault();\n\n        this.rootRenderTarget = new RenderTarget(gl, this.width, this.height, null, this.resolution, true);\n        this.rootRenderTarget.clearColor = this._backgroundColorRgba;\n\n        this.bindRenderTarget(this.rootRenderTarget);\n\n        // now lets fill up the textures with empty ones!\n        const emptyGLTexture = new glCore.GLTexture.fromData(gl, null, 1, 1);\n\n        const tempObj = { _glTextures: {} };\n\n        tempObj._glTextures[this.CONTEXT_UID] = {};\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            const empty = new BaseTexture();\n\n            empty._glTextures[this.CONTEXT_UID] = emptyGLTexture;\n\n            this.boundTextures[i] = tempObj;\n            this.emptyTextures[i] = empty;\n            this.bindTexture(null, i);\n        }\n\n        this.emit('context', gl);\n\n        // setup the width/height properties and gl viewport\n        this.resize(this.screen.width, this.screen.height);\n    }\n\n    /**\n     * Renders the object to its webGL view\n     *\n     * @param {PIXI.DisplayObject} displayObject - the object to be rendered\n     * @param {PIXI.RenderTexture} renderTexture - The render texture to render to.\n     * @param {boolean} [clear] - Should the canvas be cleared before the new render\n     * @param {PIXI.Transform} [transform] - A transform to apply to the render texture before rendering.\n     * @param {boolean} [skipUpdateTransform] - Should we skip the update transform pass?\n     */\n    render(displayObject, renderTexture, clear, transform, skipUpdateTransform)\n    {\n        // can be handy to know!\n        this.renderingToScreen = !renderTexture;\n\n        this.emit('prerender');\n\n        // no point rendering if our context has been blown up!\n        if (!this.gl || this.gl.isContextLost())\n        {\n            return;\n        }\n\n        this._nextTextureLocation = 0;\n\n        if (!renderTexture)\n        {\n            this._lastObjectRendered = displayObject;\n        }\n\n        if (!skipUpdateTransform)\n        {\n            // update the scene graph\n            const cacheParent = displayObject.parent;\n\n            displayObject.parent = this._tempDisplayObjectParent;\n            displayObject.updateTransform();\n            displayObject.parent = cacheParent;\n           // displayObject.hitArea = //TODO add a temp hit area\n        }\n\n        this.bindRenderTexture(renderTexture, transform);\n\n        this.currentRenderer.start();\n\n        if (clear !== undefined ? clear : this.clearBeforeRender)\n        {\n            this._activeRenderTarget.clear();\n        }\n\n        displayObject.renderWebGL(this);\n\n        // apply transform..\n        this.currentRenderer.flush();\n\n        // this.setObjectRenderer(this.emptyRenderer);\n\n        this.textureGC.update();\n\n        this.emit('postrender');\n    }\n\n    /**\n     * Changes the current renderer to the one given in parameter\n     *\n     * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.\n     */\n    setObjectRenderer(objectRenderer)\n    {\n        if (this.currentRenderer === objectRenderer)\n        {\n            return;\n        }\n\n        this.currentRenderer.stop();\n        this.currentRenderer = objectRenderer;\n        this.currentRenderer.start();\n    }\n\n    /**\n     * This should be called if you wish to do some custom rendering\n     * It will basically render anything that may be batched up such as sprites\n     *\n     */\n    flush()\n    {\n        this.setObjectRenderer(this.emptyRenderer);\n    }\n\n    /**\n     * Resizes the webGL view to the specified width and height.\n     *\n     * @param {number} screenWidth - the new width of the screen\n     * @param {number} screenHeight - the new height of the screen\n     */\n    resize(screenWidth, screenHeight)\n    {\n      //  if(width * this.resolution === this.width && height * this.resolution === this.height)return;\n\n        SystemRenderer.prototype.resize.call(this, screenWidth, screenHeight);\n\n        this.rootRenderTarget.resize(screenWidth, screenHeight);\n\n        if (this._activeRenderTarget === this.rootRenderTarget)\n        {\n            this.rootRenderTarget.activate();\n\n            if (this._activeShader)\n            {\n                this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true);\n            }\n        }\n    }\n\n    /**\n     * Resizes the webGL view to the specified width and height.\n     *\n     * @param {number} blendMode - the desired blend mode\n     */\n    setBlendMode(blendMode)\n    {\n        this.state.setBlendMode(blendMode);\n    }\n\n    /**\n     * Erases the active render target and fills the drawing area with a colour\n     *\n     * @param {number} [clearColor] - The colour\n     */\n    clear(clearColor)\n    {\n        this._activeRenderTarget.clear(clearColor);\n    }\n\n    /**\n     * Sets the transform of the active render target to the given matrix\n     *\n     * @param {PIXI.Matrix} matrix - The transformation matrix\n     */\n    setTransform(matrix)\n    {\n        this._activeRenderTarget.transform = matrix;\n    }\n\n    /**\n     * Erases the render texture and fills the drawing area with a colour\n     *\n     * @param {PIXI.RenderTexture} renderTexture - The render texture to clear\n     * @param {number} [clearColor] - The colour\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    clearRenderTexture(renderTexture, clearColor)\n    {\n        const baseTexture = renderTexture.baseTexture;\n        const renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];\n\n        if (renderTarget)\n        {\n            renderTarget.clear(clearColor);\n        }\n\n        return this;\n    }\n\n    /**\n     * Binds a render texture for rendering\n     *\n     * @param {PIXI.RenderTexture} renderTexture - The render texture to render\n     * @param {PIXI.Transform} transform - The transform to be applied to the render texture\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindRenderTexture(renderTexture, transform)\n    {\n        let renderTarget;\n\n        if (renderTexture)\n        {\n            const baseTexture = renderTexture.baseTexture;\n\n            if (!baseTexture._glRenderTargets[this.CONTEXT_UID])\n            {\n                // bind the current texture\n                this.textureManager.updateTexture(baseTexture, 0);\n            }\n\n            this.unbindTexture(baseTexture);\n\n            renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];\n            renderTarget.setFrame(renderTexture.frame);\n        }\n        else\n        {\n            renderTarget = this.rootRenderTarget;\n        }\n\n        renderTarget.transform = transform;\n        this.bindRenderTarget(renderTarget);\n\n        return this;\n    }\n\n    /**\n     * Changes the current render target to the one given in parameter\n     *\n     * @param {PIXI.RenderTarget} renderTarget - the new render target\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindRenderTarget(renderTarget)\n    {\n        if (renderTarget !== this._activeRenderTarget)\n        {\n            this._activeRenderTarget = renderTarget;\n            renderTarget.activate();\n\n            if (this._activeShader)\n            {\n                this._activeShader.uniforms.projectionMatrix = renderTarget.projectionMatrix.toArray(true);\n            }\n\n            this.stencilManager.setMaskStack(renderTarget.stencilMaskStack);\n        }\n\n        return this;\n    }\n\n    /**\n     * Changes the current shader to the one given in parameter\n     *\n     * @param {PIXI.Shader} shader - the new shader\n     * @param {boolean} [autoProject=true] - Whether automatically set the projection matrix\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindShader(shader, autoProject)\n    {\n        // TODO cache\n        if (this._activeShader !== shader)\n        {\n            this._activeShader = shader;\n            shader.bind();\n\n            // `autoProject` normally would be a default parameter set to true\n            // but because of how Babel transpiles default parameters\n            // it hinders the performance of this method.\n            if (autoProject !== false)\n            {\n                // automatically set the projection matrix\n                shader.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Binds the texture. This will return the location of the bound texture.\n     * It may not be the same as the one you pass in. This is due to optimisation that prevents\n     * needless binding of textures. For example if the texture is already bound it will return the\n     * current location of the texture instead of the one provided. To bypass this use force location\n     *\n     * @param {PIXI.Texture} texture - the new texture\n     * @param {number} location - the suggested texture location\n     * @param {boolean} forceLocation - force the location\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindTexture(texture, location, forceLocation)\n    {\n        texture = texture || this.emptyTextures[location];\n        texture = texture.baseTexture || texture;\n        texture.touched = this.textureGC.count;\n\n        if (!forceLocation)\n        {\n            // TODO - maybe look into adding boundIds.. save us the loop?\n            for (let i = 0; i < this.boundTextures.length; i++)\n            {\n                if (this.boundTextures[i] === texture)\n                {\n                    return i;\n                }\n            }\n\n            if (location === undefined)\n            {\n                this._nextTextureLocation++;\n                this._nextTextureLocation %= this.boundTextures.length;\n                location = this.boundTextures.length - this._nextTextureLocation - 1;\n            }\n        }\n        else\n        {\n            location = location || 0;\n        }\n\n        const gl = this.gl;\n        const glTexture = texture._glTextures[this.CONTEXT_UID];\n\n        if (!glTexture)\n        {\n            // this will also bind the texture..\n            this.textureManager.updateTexture(texture, location);\n        }\n        else\n        {\n            // bind the current texture\n            this.boundTextures[location] = texture;\n            gl.activeTexture(gl.TEXTURE0 + location);\n            gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n        }\n\n        return location;\n    }\n\n     /**\n     * unbinds the texture ...\n     *\n     * @param {PIXI.Texture} texture - the texture to unbind\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    unbindTexture(texture)\n    {\n        const gl = this.gl;\n\n        texture = texture.baseTexture || texture;\n\n        for (let i = 0; i < this.boundTextures.length; i++)\n        {\n            if (this.boundTextures[i] === texture)\n            {\n                this.boundTextures[i] = this.emptyTextures[i];\n\n                gl.activeTexture(gl.TEXTURE0 + i);\n                gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[i]._glTextures[this.CONTEXT_UID].texture);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Creates a new VAO from this renderer's context and state.\n     *\n     * @return {VertexArrayObject} The new VAO.\n     */\n    createVao()\n    {\n        return new glCore.VertexArrayObject(this.gl, this.state.attribState);\n    }\n\n    /**\n     * Changes the current Vao to the one given in parameter\n     *\n     * @param {PIXI.VertexArrayObject} vao - the new Vao\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindVao(vao)\n    {\n        if (this._activeVao === vao)\n        {\n            return this;\n        }\n\n        if (vao)\n        {\n            vao.bind();\n        }\n        else if (this._activeVao)\n        {\n            // TODO this should always be true i think?\n            this._activeVao.unbind();\n        }\n\n        this._activeVao = vao;\n\n        return this;\n    }\n\n    /**\n     * Resets the WebGL state so you can render things however you fancy!\n     *\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    reset()\n    {\n        this.setObjectRenderer(this.emptyRenderer);\n\n        this._activeShader = null;\n        this._activeRenderTarget = this.rootRenderTarget;\n\n        // bind the main frame buffer (the screen);\n        this.rootRenderTarget.activate();\n\n        this.state.resetToDefault();\n\n        return this;\n    }\n\n    /**\n     * Handles a lost webgl context\n     *\n     * @private\n     * @param {WebGLContextEvent} event - The context lost event.\n     */\n    handleContextLost(event)\n    {\n        event.preventDefault();\n    }\n\n    /**\n     * Handles a restored webgl context\n     *\n     * @private\n     */\n    handleContextRestored()\n    {\n        this.textureManager.removeAll();\n        this._initContext();\n    }\n\n    /**\n     * Removes everything from the renderer (event listeners, spritebatch, etc...)\n     *\n     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n     *  See: https://github.com/pixijs/pixi.js/issues/2233\n     */\n    destroy(removeView)\n    {\n        this.destroyPlugins();\n\n        // remove listeners\n        this.view.removeEventListener('webglcontextlost', this.handleContextLost);\n        this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);\n\n        this.textureManager.destroy();\n\n        // call base destroy\n        super.destroy(removeView);\n\n        this.uid = 0;\n\n        // destroy the managers\n        this.maskManager.destroy();\n        this.stencilManager.destroy();\n        this.filterManager.destroy();\n\n        this.maskManager = null;\n        this.filterManager = null;\n        this.textureManager = null;\n        this.currentRenderer = null;\n\n        this.handleContextLost = null;\n        this.handleContextRestored = null;\n\n        this._contextOptions = null;\n        this.gl.useProgram(null);\n\n        if (this.gl.getExtension('WEBGL_lose_context'))\n        {\n            this.gl.getExtension('WEBGL_lose_context').loseContext();\n        }\n\n        this.gl = null;\n\n        // this = null;\n    }\n}\n\n/**\n * Collection of installed plugins. These are included by default in PIXI, but can be excluded\n * by creating a custom build. Consult the README for more information about creating custom\n * builds and excluding plugins.\n * @name PIXI.WebGLRenderer#plugins\n * @type {object}\n * @readonly\n * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.\n * @property {PIXI.extract.WebGLExtract} extract Extract image data from renderer.\n * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.\n * @property {PIXI.prepare.WebGLPrepare} prepare Pre-render display objects.\n */\n\n/**\n * Adds a plugin to the renderer.\n *\n * @method PIXI.WebGLRenderer#registerPlugin\n * @param {string} pluginName - The name of the plugin.\n * @param {Function} ctor - The constructor function or class for the plugin.\n */\n\npluginTarget.mixin(WebGLRenderer);\n"]}