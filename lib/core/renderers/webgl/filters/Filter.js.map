{"version":3,"sources":["../../../../../src/core/renderers/webgl/filters/Filter.js"],"names":["SOURCE_KEY_MAP","Filter","vertexSrc","fragmentSrc","uniforms","defaultVertexSrc","defaultFragmentSrc","blendMode","NORMAL","uniformData","i","value","glShaders","glShaderKey","padding","resolution","RESOLUTION","enabled","apply","filterManager","input","output","clear","currentState","applyFilter","join"],"mappings":";;;;;;AAAA;;;;AACA;;AACA;;AACA;;;;;;;;AAEA,IAAMA,iBAAiB,EAAvB;;AAEA;AACA;;;;;;IAKqBC,M;AAEjB;;;;;AAKA,kBAAYC,SAAZ,EAAuBC,WAAvB,EAAoCC,QAApC,EACA;AAAA;;AACI;;;;;AAKA,SAAKF,SAAL,GAAiBA,aAAaD,OAAOI,gBAArC;;AAEA;;;;;AAKA,SAAKF,WAAL,GAAmBA,eAAeF,OAAOK,kBAAzC;;AAEA,SAAKC,SAAL,GAAiB,mBAAYC,MAA7B;;AAEA,SAAKC,WAAL,GAAmBL,YAAY,sCAAuB,KAAKF,SAA5B,EAAuC,KAAKC,WAA5C,EAAyD,2BAAzD,CAA/B;;AAEA;;;;;;;AAOA,SAAKC,QAAL,GAAgB,EAAhB;;AAEA,SAAK,IAAMM,CAAX,IAAgB,KAAKD,WAArB,EACA;AACI,WAAKL,QAAL,CAAcM,CAAd,IAAmB,KAAKD,WAAL,CAAiBC,CAAjB,EAAoBC,KAAvC;AACH;;AAED;AACA;AACA,SAAKC,SAAL,GAAiB,EAAjB;;AAEA;AACA,QAAI,CAACZ,eAAe,KAAKE,SAAL,GAAiB,KAAKC,WAArC,CAAL,EACA;AACIH,qBAAe,KAAKE,SAAL,GAAiB,KAAKC,WAArC,IAAoD,iBAApD;AACH;;AAED,SAAKU,WAAL,GAAmBb,eAAe,KAAKE,SAAL,GAAiB,KAAKC,WAArC,CAAnB;;AAEA;;;;;;;AAOA,SAAKW,OAAL,GAAe,CAAf;;AAEA;;;;;;AAMA,SAAKC,UAAL,GAAkB,mBAASC,UAA3B;;AAEA;;;;;AAKA,SAAKC,OAAL,GAAe,IAAf;AACH;;AAED;;;;;;;;;;;;;mBAWAC,K,kBAAMC,a,EAAeC,K,EAAOC,M,EAAQC,K,EAAOC,Y,EAAc;AACzD;AACI;AACA;;AAEA;;AAEAJ,kBAAcK,WAAd,CAA0B,IAA1B,EAAgCJ,KAAhC,EAAuCC,MAAvC,EAA+CC,KAA/C;;AAEA;AACH,G;;AAED;;;;;;;;;;wBAOA;AACI,aAAO,CACH,iCADG,EAEH,+BAFG,EAIH,gCAJG,EAKH,4BALG,EAOH,6BAPG,EAQH,4BARG,EAUH,kBAVG,EAWH,sFAXG,EAYH,qEAZG,EAaH,oCAbG,EAcH,GAdG,EAeLG,IAfK,CAeA,IAfA,CAAP;AAgBH;;AAED;;;;;;;;;wBAOA;AACI,aAAO,CACH,6BADG,EAEH,4BAFG,EAIH,6BAJG,EAKH,kCALG,EAOH,kBAPG,EAQH,yDARG,EASH,sDATG,EAUH,gBAVG,EAWH,uCAXG,EAYH,MAZG,EAaH,wCAbG,EAcH,MAdG,EAeH,SAfG,EAgBH,MAhBG,EAiBH,wCAjBG,EAkBH,MAlBG;AAmBH;AACA,kDApBG,EAqBH,8BArBG,EAsBH,GAtBG,EAuBLA,IAvBK,CAuBA,IAvBA,CAAP;AAwBH;;;;;;kBA/JgBxB,M","file":"Filter.js","sourcesContent":["import extractUniformsFromSrc from './extractUniformsFromSrc';\nimport { uid } from '../../../utils';\nimport { BLEND_MODES } from '../../../const';\nimport settings from '../../../settings';\n\nconst SOURCE_KEY_MAP = {};\n\n// let math = require('../../../math');\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.Shader\n */\nexport default class Filter\n{\n    /**\n     * @param {string} [vertexSrc] - The source of the vertex shader.\n     * @param {string} [fragmentSrc] - The source of the fragment shader.\n     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.\n     */\n    constructor(vertexSrc, fragmentSrc, uniforms)\n    {\n        /**\n         * The vertex shader.\n         *\n         * @member {string}\n         */\n        this.vertexSrc = vertexSrc || Filter.defaultVertexSrc;\n\n        /**\n         * The fragment shader.\n         *\n         * @member {string}\n         */\n        this.fragmentSrc = fragmentSrc || Filter.defaultFragmentSrc;\n\n        this.blendMode = BLEND_MODES.NORMAL;\n\n        this.uniformData = uniforms || extractUniformsFromSrc(this.vertexSrc, this.fragmentSrc, 'projectionMatrix|uSampler');\n\n        /**\n         * An object containing the current values of custom uniforms.\n         * @example <caption>Updating the value of a custom uniform</caption>\n         * filter.uniforms.time = performance.now();\n         *\n         * @member {object}\n         */\n        this.uniforms = {};\n\n        for (const i in this.uniformData)\n        {\n            this.uniforms[i] = this.uniformData[i].value;\n        }\n\n        // this is where we store shader references..\n        // TODO we could cache this!\n        this.glShaders = {};\n\n        // used for cacheing.. sure there is a better way!\n        if (!SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc])\n        {\n            SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc] = uid();\n        }\n\n        this.glShaderKey = SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc];\n\n        /**\n         * The padding of the filter. Some filters require extra space to breath such as a blur.\n         * Increasing this will add extra width and height to the bounds of the object that the\n         * filter is applied to.\n         *\n         * @member {number}\n         */\n        this.padding = 4;\n\n        /**\n         * The resolution of the filter. Setting this to be lower will lower the quality but\n         * increase the performance of the filter.\n         *\n         * @member {number}\n         */\n        this.resolution = settings.RESOLUTION;\n\n        /**\n         * If enabled is true the filter is applied, if false it will not.\n         *\n         * @member {boolean}\n         */\n        this.enabled = true;\n    }\n\n    /**\n     * Applies the filter\n     *\n     * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from\n     * @param {PIXI.RenderTarget} input - The input render target.\n     * @param {PIXI.RenderTarget} output - The target to output to.\n     * @param {boolean} clear - Should the output be cleared before rendering to it\n     * @param {object} [currentState] - It's current state of filter.\n     *        There are some useful properties in the currentState :\n     *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution\n     */\n    apply(filterManager, input, output, clear, currentState) // eslint-disable-line no-unused-vars\n    {\n        // --- //\n        //  this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(tempMatrix, window.panda );\n\n        // do as you please!\n\n        filterManager.applyFilter(this, input, output, clear);\n\n        // or just do a regular render..\n    }\n\n    /**\n     * The default vertex shader source\n     *\n     * @static\n     * @constant\n     */\n    static get defaultVertexSrc()\n    {\n        return [\n            'attribute vec2 aVertexPosition;',\n            'attribute vec2 aTextureCoord;',\n\n            'uniform mat3 projectionMatrix;',\n            'uniform mat3 filterMatrix;',\n\n            'varying vec2 vTextureCoord;',\n            'varying vec2 vFilterCoord;',\n\n            'void main(void){',\n            '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n            '   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;',\n            '   vTextureCoord = aTextureCoord ;',\n            '}',\n        ].join('\\n');\n    }\n\n    /**\n     * The default fragment shader source\n     *\n     * @static\n     * @constant\n     */\n    static get defaultFragmentSrc()\n    {\n        return [\n            'varying vec2 vTextureCoord;',\n            'varying vec2 vFilterCoord;',\n\n            'uniform sampler2D uSampler;',\n            'uniform sampler2D filterSampler;',\n\n            'void main(void){',\n            '   vec4 masky = texture2D(filterSampler, vFilterCoord);',\n            '   vec4 sample = texture2D(uSampler, vTextureCoord);',\n            '   vec4 color;',\n            '   if(mod(vFilterCoord.x, 1.0) > 0.5)',\n            '   {',\n            '     color = vec4(1.0, 0.0, 0.0, 1.0);',\n            '   }',\n            '   else',\n            '   {',\n            '     color = vec4(0.0, 1.0, 0.0, 1.0);',\n            '   }',\n            // '   gl_FragColor = vec4(mod(vFilterCoord.x, 1.5), vFilterCoord.y,0.0,1.0);',\n            '   gl_FragColor = mix(sample, masky, 0.5);',\n            '   gl_FragColor *= sample.a;',\n            '}',\n        ].join('\\n');\n    }\n}\n"]}