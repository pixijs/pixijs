{"version":3,"sources":["../../../../../src/core/renderers/webgl/filters/filterTransforms.js"],"names":["calculateScreenSpaceMatrix","calculateNormalizedScreenSpaceMatrix","calculateSpriteMatrix","outputMatrix","filterArea","textureSize","mappedMatrix","identity","translate","x","width","y","height","scale","translateScaleX","translateScaleY","sprite","worldTransform","copy","TEMP_MATRIX","texture","_texture","baseTexture","ratio","tx","ty","invert","prepend","anchor"],"mappings":";;;QAUgBA,0B,GAAAA,0B;QAeAC,oC,GAAAA,oC;QAeAC,qB,GAAAA,qB;;AAxChB;;AAEA;;;;;;AAMA;AACA;AACO,SAASF,0BAAT,CAAoCG,YAApC,EAAkDC,UAAlD,EAA8DC,WAA9D,EACP;AACK;AACD;;AAEA;AACA,QAAMC,eAAeH,aAAaI,QAAb,EAArB;;AAEAD,iBAAaE,SAAb,CAAuBJ,WAAWK,CAAX,GAAeJ,YAAYK,KAAlD,EAAyDN,WAAWO,CAAX,GAAeN,YAAYO,MAApF;;AAEAN,iBAAaO,KAAb,CAAmBR,YAAYK,KAA/B,EAAsCL,YAAYO,MAAlD;;AAEA,WAAON,YAAP;AACH;;AAEM,SAASL,oCAAT,CAA8CE,YAA9C,EAA4DC,UAA5D,EAAwEC,WAAxE,EACP;AACI,QAAMC,eAAeH,aAAaI,QAAb,EAArB;;AAEAD,iBAAaE,SAAb,CAAuBJ,WAAWK,CAAX,GAAeJ,YAAYK,KAAlD,EAAyDN,WAAWO,CAAX,GAAeN,YAAYO,MAApF;;AAEA,QAAME,kBAAmBT,YAAYK,KAAZ,GAAoBN,WAAWM,KAAxD;AACA,QAAMK,kBAAmBV,YAAYO,MAAZ,GAAqBR,WAAWQ,MAAzD;;AAEAN,iBAAaO,KAAb,CAAmBC,eAAnB,EAAoCC,eAApC;;AAEA,WAAOT,YAAP;AACH;;AAED;AACO,SAASJ,qBAAT,CAA+BC,YAA/B,EAA6CC,UAA7C,EAAyDC,WAAzD,EAAsEW,MAAtE,EACP;AACI,QAAMC,iBAAiBD,OAAOC,cAAP,CAAsBC,IAAtB,CAA2B,aAAOC,WAAlC,CAAvB;AACA,QAAMC,UAAUJ,OAAOK,QAAP,CAAgBC,WAAhC;;AAEA;AACA,QAAMhB,eAAeH,aAAaI,QAAb,EAArB;;AAEA;AACA,QAAMgB,QAAQlB,YAAYO,MAAZ,GAAqBP,YAAYK,KAA/C;;AAEAJ,iBAAaE,SAAb,CAAuBJ,WAAWK,CAAX,GAAeJ,YAAYK,KAAlD,EAAyDN,WAAWO,CAAX,GAAeN,YAAYO,MAApF;;AAEAN,iBAAaO,KAAb,CAAmB,CAAnB,EAAsBU,KAAtB;;AAEA,QAAMT,kBAAmBT,YAAYK,KAAZ,GAAoBU,QAAQV,KAArD;AACA,QAAMK,kBAAmBV,YAAYO,MAAZ,GAAqBQ,QAAQR,MAAtD;;AAEAK,mBAAeO,EAAf,IAAqBJ,QAAQV,KAAR,GAAgBI,eAArC;;AAEA;AACAG,mBAAeQ,EAAf,IAAqBL,QAAQV,KAAR,GAAgBI,eAArC;AACA;;AAEAG,mBAAeS,MAAf;AACApB,iBAAaqB,OAAb,CAAqBV,cAArB;;AAEA;AACAX,iBAAaO,KAAb,CAAmB,CAAnB,EAAsB,IAAIU,KAA1B;;AAEAjB,iBAAaO,KAAb,CAAmBC,eAAnB,EAAoCC,eAApC;;AAEAT,iBAAaE,SAAb,CAAuBQ,OAAOY,MAAP,CAAcnB,CAArC,EAAwCO,OAAOY,MAAP,CAAcjB,CAAtD;;AAEA,WAAOL,YAAP;AACH","file":"filterTransforms.js","sourcesContent":["import { Matrix } from '../../../math';\n\n/**\n * Calculates the mapped matrix\n * @param filterArea {Rectangle} The filter area\n * @param sprite {Sprite} the target sprite\n * @param outputMatrix {Matrix} @alvin\n */\n// TODO playing around here.. this is temporary - (will end up in the shader)\n// this returns a matrix that will normalise map filter cords in the filter to screen space\nexport function calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize)\n{\n     // let worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX),\n    // let texture = {width:1136, height:700};//sprite._texture.baseTexture;\n\n    // TODO unwrap?\n    const mappedMatrix = outputMatrix.identity();\n\n    mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n\n    mappedMatrix.scale(textureSize.width, textureSize.height);\n\n    return mappedMatrix;\n}\n\nexport function calculateNormalizedScreenSpaceMatrix(outputMatrix, filterArea, textureSize)\n{\n    const mappedMatrix = outputMatrix.identity();\n\n    mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n\n    const translateScaleX = (textureSize.width / filterArea.width);\n    const translateScaleY = (textureSize.height / filterArea.height);\n\n    mappedMatrix.scale(translateScaleX, translateScaleY);\n\n    return mappedMatrix;\n}\n\n// this will map the filter coord so that a texture can be used based on the transform of a sprite\nexport function calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite)\n{\n    const worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX);\n    const texture = sprite._texture.baseTexture;\n\n    // TODO unwrap?\n    const mappedMatrix = outputMatrix.identity();\n\n    // scale..\n    const ratio = textureSize.height / textureSize.width;\n\n    mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n\n    mappedMatrix.scale(1, ratio);\n\n    const translateScaleX = (textureSize.width / texture.width);\n    const translateScaleY = (textureSize.height / texture.height);\n\n    worldTransform.tx /= texture.width * translateScaleX;\n\n    // this...?  free beer for anyone who can explain why this makes sense!\n    worldTransform.ty /= texture.width * translateScaleX;\n    // worldTransform.ty /= texture.height * translateScaleY;\n\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n\n    // apply inverse scale..\n    mappedMatrix.scale(1, 1 / ratio);\n\n    mappedMatrix.scale(translateScaleX, translateScaleY);\n\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n    return mappedMatrix;\n}\n"]}