{"version":3,"sources":["../../../src/core/textures/RenderTexture.js"],"names":["RenderTexture","baseRenderTexture","frame","_legacyRenderer","width","arguments","height","scaleMode","resolution","console","warn","legacyRenderer","valid","_updateUvs","resize","doNotResizeBaseTexture","_frame","orig","baseTexture","create"],"mappings":";;;;AAAA;;;;AACA;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAqCqBA,a;;;AAEjB;;;;AAIA,2BAAYC,iBAAZ,EAA+BC,KAA/B,EACA;AAAA;;AACI;AACA,YAAIC,kBAAkB,IAAtB;;AAEA,YAAI,EAAEF,wDAAF,CAAJ,EACA;AACI;AACA,gBAAMG,QAAQC,UAAU,CAAV,CAAd;AACA,gBAAMC,SAASD,UAAU,CAAV,CAAf;AACA,gBAAME,YAAYF,UAAU,CAAV,KAAgB,CAAlC;AACA,gBAAMG,aAAaH,UAAU,CAAV,KAAgB,CAAnC;;AAEA;AACAI,oBAAQC,IAAR,sCAAgDN,KAAhD,UAA0DE,MAA1D;AACAH,8BAAkBE,UAAU,CAAV,CAAlB;AACA;;AAEAH,oBAAQ,IAAR;AACAD,gCAAoB,gCAAsBG,KAAtB,EAA6BE,MAA7B,EAAqCC,SAArC,EAAgDC,UAAhD,CAApB;AACH;;AAED;;;;;;AArBJ,qDA0BI,oBACIP,iBADJ,EAEIC,KAFJ,CA1BJ;;AA+BI,cAAKS,cAAL,GAAsBR,eAAtB;;AAEA;;;;;AAKA,cAAKS,KAAL,GAAa,IAAb;;AAEA,cAAKC,UAAL;AAxCJ;AAyCC;;AAED;;;;;;;;;4BAOAC,M,mBAAOV,K,EAAOE,M,EAAQS,sB,EACtB;AACI;AACA,aAAKH,KAAL,GAAcR,QAAQ,CAAR,IAAaE,SAAS,CAApC;;AAEA,aAAKU,MAAL,CAAYZ,KAAZ,GAAoB,KAAKa,IAAL,CAAUb,KAAV,GAAkBA,KAAtC;AACA,aAAKY,MAAL,CAAYV,MAAZ,GAAqB,KAAKW,IAAL,CAAUX,MAAV,GAAmBA,MAAxC;;AAEA,YAAI,CAACS,sBAAL,EACA;AACI,iBAAKG,WAAL,CAAiBJ,MAAjB,CAAwBV,KAAxB,EAA+BE,MAA/B;AACH;;AAED,aAAKO,UAAL;AACH,K;;AAED;;;;;;;;;;;kBASOM,M,mBAAOf,K,EAAOE,M,EAAQC,S,EAAWC,U,EACxC;AACI,eAAO,IAAIR,aAAJ,CAAkB,gCAAsBI,KAAtB,EAA6BE,MAA7B,EAAqCC,SAArC,EAAgDC,UAAhD,CAAlB,CAAP;AACH,K;;;;;kBArFgBR,a","file":"RenderTexture.js","sourcesContent":["import BaseRenderTexture from './BaseRenderTexture';\nimport Texture from './Texture';\n\n/**\n * A RenderTexture is a special texture that allows any Pixi display object to be rendered to it.\n *\n * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded\n * otherwise black rectangles will be drawn instead.\n *\n * A RenderTexture takes a snapshot of any Display Object given to its render method. The position\n * and rotation of the given Display Objects is ignored. For example:\n *\n * ```js\n * let renderer = PIXI.autoDetectRenderer(1024, 1024, { view: canvas, ratio: 1 });\n * let renderTexture = PIXI.RenderTexture.create(800, 600);\n * let sprite = PIXI.Sprite.fromImage(\"spinObj_01.png\");\n *\n * sprite.position.x = 800/2;\n * sprite.position.y = 600/2;\n * sprite.anchor.x = 0.5;\n * sprite.anchor.y = 0.5;\n *\n * renderer.render(sprite, renderTexture);\n * ```\n *\n * The Sprite in this case will be rendered to a position of 0,0. To render this sprite at its actual\n * position a Container should be used:\n *\n * ```js\n * let doc = new PIXI.Container();\n *\n * doc.addChild(sprite);\n *\n * renderer.render(doc, renderTexture);  // Renders to center of renderTexture\n * ```\n *\n * @class\n * @extends PIXI.Texture\n * @memberof PIXI\n */\nexport default class RenderTexture extends Texture\n{\n    /**\n     * @param {PIXI.BaseRenderTexture} baseRenderTexture - The renderer used for this RenderTexture\n     * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show\n     */\n    constructor(baseRenderTexture, frame)\n    {\n        // support for legacy..\n        let _legacyRenderer = null;\n\n        if (!(baseRenderTexture instanceof BaseRenderTexture))\n        {\n            /* eslint-disable prefer-rest-params, no-console */\n            const width = arguments[1];\n            const height = arguments[2];\n            const scaleMode = arguments[3] || 0;\n            const resolution = arguments[4] || 1;\n\n            // we have an old render texture..\n            console.warn(`Please use RenderTexture.create(${width}, ${height}) instead of the ctor directly.`);\n            _legacyRenderer = arguments[0];\n            /* eslint-enable prefer-rest-params, no-console */\n\n            frame = null;\n            baseRenderTexture = new BaseRenderTexture(width, height, scaleMode, resolution);\n        }\n\n        /**\n         * The base texture object that this texture uses\n         *\n         * @member {BaseTexture}\n         */\n        super(\n            baseRenderTexture,\n            frame\n        );\n\n        this.legacyRenderer = _legacyRenderer;\n\n        /**\n         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n         *\n         * @member {boolean}\n         */\n        this.valid = true;\n\n        this._updateUvs();\n    }\n\n    /**\n     * Resizes the RenderTexture.\n     *\n     * @param {number} width - The width to resize to.\n     * @param {number} height - The height to resize to.\n     * @param {boolean} doNotResizeBaseTexture - Should the baseTexture.width and height values be resized as well?\n     */\n    resize(width, height, doNotResizeBaseTexture)\n    {\n        // TODO - could be not required..\n        this.valid = (width > 0 && height > 0);\n\n        this._frame.width = this.orig.width = width;\n        this._frame.height = this.orig.height = height;\n\n        if (!doNotResizeBaseTexture)\n        {\n            this.baseTexture.resize(width, height);\n        }\n\n        this._updateUvs();\n    }\n\n    /**\n     * A short hand way of creating a render texture.\n     *\n     * @param {number} [width=100] - The width of the render texture\n     * @param {number} [height=100] - The height of the render texture\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated\n     * @return {PIXI.RenderTexture} The new render texture\n     */\n    static create(width, height, scaleMode, resolution)\n    {\n        return new RenderTexture(new BaseRenderTexture(width, height, scaleMode, resolution));\n    }\n}\n"]}