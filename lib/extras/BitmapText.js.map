{"version":3,"sources":["../../src/extras/BitmapText.js"],"names":["core","BitmapText","text","style","_textWidth","_textHeight","_glyphs","_font","tint","undefined","align","name","size","font","_text","maxWidth","maxLineHeight","_anchor","dirty","updateText","data","fonts","scale","pos","Point","chars","lineWidths","prevCharCode","lastLineWidth","maxLineWidth","line","lastSpace","lastSpaceWidth","i","length","charCode","charCodeAt","test","charAt","push","Math","max","x","y","lineHeight","utils","removeItems","charData","kerning","texture","position","xOffset","yOffset","width","xAdvance","height","lineAlignOffsets","alignOffset","lenChars","c","Sprite","parent","addChild","removeChild","anchor","updateTransform","validate","containerUpdateTransform","getLocalBounds","registerFont","xml","info","getElementsByTagName","common","getAttribute","parseInt","letters","letter","textureRect","Rectangle","frame","Texture","baseTexture","kernings","first","second","amount","value","set","copy","split","slice","join","toString","Container"],"mappings":"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","file":"BitmapText.js","sourcesContent":["import * as core from '../core';\nimport ObservablePoint from '../core/math/ObservablePoint';\n\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font. To\n * split a line you can use '\\n', '\\r' or '\\r\\n' in your string. You can generate the fnt files using:\n *\n * A BitmapText can only be created when the font is loaded\n *\n * ```js\n * // in this case the font is in a file called 'desyrel.fnt'\n * let bitmapText = new PIXI.extras.BitmapText(\"text using a fancy font!\", {font: \"35px Desyrel\", align: \"right\"});\n * ```\n *\n * http://www.angelcode.com/products/bmfont/ for windows or\n * http://www.bmglyph.com/ for mac.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.extras\n */\nexport default class BitmapText extends core.Container\n{\n    /**\n     * @param {string} text - The copy that you would like the text to display\n     * @param {object} style - The style parameters\n     * @param {string|object} style.font - The font descriptor for the object, can be passed as a string of form\n     *      \"24px FontName\" or \"FontName\" or as an object with explicit name/size properties.\n     * @param {string} [style.font.name] - The bitmap font id\n     * @param {number} [style.font.size] - The size of the font in pixels, e.g. 24\n     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'), does not affect\n     *      single line text\n     * @param {number} [style.tint=0xFFFFFF] - The tint color\n     */\n    constructor(text, style = {})\n    {\n        super();\n\n        /**\n         * Private tracker for the width of the overall text\n         *\n         * @member {number}\n         * @private\n         */\n        this._textWidth = 0;\n\n        /**\n         * Private tracker for the height of the overall text\n         *\n         * @member {number}\n         * @private\n         */\n        this._textHeight = 0;\n\n        /**\n         * Private tracker for the letter sprite pool.\n         *\n         * @member {PIXI.Sprite[]}\n         * @private\n         */\n        this._glyphs = [];\n\n        /**\n         * Private tracker for the current style.\n         *\n         * @member {object}\n         * @private\n         */\n        this._font = {\n            tint: style.tint !== undefined ? style.tint : 0xFFFFFF,\n            align: style.align || 'left',\n            name: null,\n            size: 0,\n        };\n\n        /**\n         * Private tracker for the current font.\n         *\n         * @member {object}\n         * @private\n         */\n        this.font = style.font; // run font setter\n\n        /**\n         * Private tracker for the current text.\n         *\n         * @member {string}\n         * @private\n         */\n        this._text = text;\n\n        /**\n         * The max width of this bitmap text in pixels. If the text provided is longer than the\n         * value provided, line breaks will be automatically inserted in the last whitespace.\n         * Disable by setting value to 0\n         *\n         * @member {number}\n         */\n        this.maxWidth = 0;\n\n        /**\n         * The max line height. This is useful when trying to use the total height of the Text,\n         * ie: when trying to vertically align.\n         *\n         * @member {number}\n         */\n        this.maxLineHeight = 0;\n\n        /**\n         * Text anchor. read-only\n         *\n         * @member {PIXI.ObservablePoint}\n         * @private\n         */\n        this._anchor = new ObservablePoint(() => { this.dirty = true; }, this, 0, 0);\n\n        /**\n         * The dirty state of this object.\n         *\n         * @member {boolean}\n         */\n        this.dirty = false;\n\n        this.updateText();\n    }\n\n    /**\n     * Renders text and updates it when needed\n     *\n     * @private\n     */\n    updateText()\n    {\n        const data = BitmapText.fonts[this._font.name];\n        const scale = this._font.size / data.size;\n        const pos = new core.Point();\n        const chars = [];\n        const lineWidths = [];\n\n        let prevCharCode = null;\n        let lastLineWidth = 0;\n        let maxLineWidth = 0;\n        let line = 0;\n        let lastSpace = -1;\n        let lastSpaceWidth = 0;\n        let maxLineHeight = 0;\n\n        for (let i = 0; i < this.text.length; i++)\n        {\n            const charCode = this.text.charCodeAt(i);\n\n            if (/(\\s)/.test(this.text.charAt(i)))\n            {\n                lastSpace = i;\n                lastSpaceWidth = lastLineWidth;\n            }\n\n            if (/(?:\\r\\n|\\r|\\n)/.test(this.text.charAt(i)))\n            {\n                lineWidths.push(lastLineWidth);\n                maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n                line++;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                continue;\n            }\n\n            if (lastSpace !== -1 && this.maxWidth > 0 && pos.x * scale > this.maxWidth)\n            {\n                core.utils.removeItems(chars, lastSpace, i - lastSpace);\n                i = lastSpace;\n                lastSpace = -1;\n\n                lineWidths.push(lastSpaceWidth);\n                maxLineWidth = Math.max(maxLineWidth, lastSpaceWidth);\n                line++;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                continue;\n            }\n\n            const charData = data.chars[charCode];\n\n            if (!charData)\n            {\n                continue;\n            }\n\n            if (prevCharCode && charData.kerning[prevCharCode])\n            {\n                pos.x += charData.kerning[prevCharCode];\n            }\n\n            chars.push({\n                texture: charData.texture,\n                line,\n                charCode,\n                position: new core.Point(pos.x + charData.xOffset, pos.y + charData.yOffset),\n            });\n            lastLineWidth = pos.x + (charData.texture.width + charData.xOffset);\n            pos.x += charData.xAdvance;\n            maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));\n            prevCharCode = charCode;\n        }\n\n        lineWidths.push(lastLineWidth);\n        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n\n        const lineAlignOffsets = [];\n\n        for (let i = 0; i <= line; i++)\n        {\n            let alignOffset = 0;\n\n            if (this._font.align === 'right')\n            {\n                alignOffset = maxLineWidth - lineWidths[i];\n            }\n            else if (this._font.align === 'center')\n            {\n                alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n            }\n\n            lineAlignOffsets.push(alignOffset);\n        }\n\n        const lenChars = chars.length;\n        const tint = this.tint;\n\n        for (let i = 0; i < lenChars; i++)\n        {\n            let c = this._glyphs[i]; // get the next glyph sprite\n\n            if (c)\n            {\n                c.texture = chars[i].texture;\n            }\n            else\n            {\n                c = new core.Sprite(chars[i].texture);\n                this._glyphs.push(c);\n            }\n\n            c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;\n            c.position.y = chars[i].position.y * scale;\n            c.scale.x = c.scale.y = scale;\n            c.tint = tint;\n\n            if (!c.parent)\n            {\n                this.addChild(c);\n            }\n        }\n\n        // remove unnecessary children.\n        for (let i = lenChars; i < this._glyphs.length; ++i)\n        {\n            this.removeChild(this._glyphs[i]);\n        }\n\n        this._textWidth = maxLineWidth * scale;\n        this._textHeight = (pos.y + data.lineHeight) * scale;\n\n        // apply anchor\n        if (this.anchor.x !== 0 || this.anchor.y !== 0)\n        {\n            for (let i = 0; i < lenChars; i++)\n            {\n                this._glyphs[i].x -= this._textWidth * this.anchor.x;\n                this._glyphs[i].y -= this._textHeight * this.anchor.y;\n            }\n        }\n        this.maxLineHeight = maxLineHeight * scale;\n    }\n\n    /**\n     * Updates the transform of this object\n     *\n     * @private\n     */\n    updateTransform()\n    {\n        this.validate();\n        this.containerUpdateTransform();\n    }\n\n    /**\n     * Validates text before calling parent's getLocalBounds\n     *\n     * @return {PIXI.Rectangle} The rectangular bounding area\n     */\n    getLocalBounds()\n    {\n        this.validate();\n\n        return super.getLocalBounds();\n    }\n\n    /**\n     * Updates text when needed\n     *\n     * @private\n     */\n    validate()\n    {\n        if (this.dirty)\n        {\n            this.updateText();\n            this.dirty = false;\n        }\n    }\n\n    /**\n     * The tint of the BitmapText object\n     *\n     * @member {number}\n     */\n    get tint()\n    {\n        return this._font.tint;\n    }\n\n    set tint(value) // eslint-disable-line require-jsdoc\n    {\n        this._font.tint = (typeof value === 'number' && value >= 0) ? value : 0xFFFFFF;\n\n        this.dirty = true;\n    }\n\n    /**\n     * The alignment of the BitmapText object\n     *\n     * @member {string}\n     * @default 'left'\n     */\n    get align()\n    {\n        return this._font.align;\n    }\n\n    set align(value) // eslint-disable-line require-jsdoc\n    {\n        this._font.align = value || 'left';\n\n        this.dirty = true;\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     * The default is 0,0 this means the text's origin is the top left\n     * Setting the anchor to 0.5,0.5 means the text's origin is centered\n     * Setting the anchor to 1,1 would mean the text's origin point will be the bottom right corner\n     *\n     * @member {PIXI.Point | number}\n     */\n    get anchor()\n    {\n        return this._anchor;\n    }\n\n    set anchor(value) // eslint-disable-line require-jsdoc\n    {\n        if (typeof value === 'number')\n        {\n            this._anchor.set(value);\n        }\n        else\n        {\n            this._anchor.copy(value);\n        }\n    }\n\n    /**\n     * The font descriptor of the BitmapText object\n     *\n     * @member {string|object}\n     */\n    get font()\n    {\n        return this._font;\n    }\n\n    set font(value) // eslint-disable-line require-jsdoc\n    {\n        if (!value)\n        {\n            return;\n        }\n\n        if (typeof value === 'string')\n        {\n            value = value.split(' ');\n\n            this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');\n            this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;\n        }\n        else\n        {\n            this._font.name = value.name;\n            this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);\n        }\n\n        this.dirty = true;\n    }\n\n    /**\n     * The text of the BitmapText object\n     *\n     * @member {string}\n     */\n    get text()\n    {\n        return this._text;\n    }\n\n    set text(value) // eslint-disable-line require-jsdoc\n    {\n        value = value.toString() || ' ';\n        if (this._text === value)\n        {\n            return;\n        }\n        this._text = value;\n        this.dirty = true;\n    }\n\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readonly\n     */\n    get textWidth()\n    {\n        this.validate();\n\n        return this._textWidth;\n    }\n\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readonly\n     */\n    get textHeight()\n    {\n        this.validate();\n\n        return this._textHeight;\n    }\n\n    /**\n     * Register a bitmap font with data and a texture.\n     *\n     * @static\n     * @param {XMLDocument} xml - The XML document data.\n     * @param {PIXI.Texture} texture - Texture with all symbols.\n     * @return {Object} Result font object with font, size, lineHeight and char fields.\n     */\n    static registerFont(xml, texture)\n    {\n        const data = {};\n        const info = xml.getElementsByTagName('info')[0];\n        const common = xml.getElementsByTagName('common')[0];\n\n        data.font = info.getAttribute('face');\n        data.size = parseInt(info.getAttribute('size'), 10);\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);\n        data.chars = {};\n\n        // parse letters\n        const letters = xml.getElementsByTagName('char');\n\n        for (let i = 0; i < letters.length; i++)\n        {\n            const letter = letters[i];\n            const charCode = parseInt(letter.getAttribute('id'), 10);\n\n            const textureRect = new core.Rectangle(\n                parseInt(letter.getAttribute('x'), 10) + texture.frame.x,\n                parseInt(letter.getAttribute('y'), 10) + texture.frame.y,\n                parseInt(letter.getAttribute('width'), 10),\n                parseInt(letter.getAttribute('height'), 10)\n            );\n\n            data.chars[charCode] = {\n                xOffset: parseInt(letter.getAttribute('xoffset'), 10),\n                yOffset: parseInt(letter.getAttribute('yoffset'), 10),\n                xAdvance: parseInt(letter.getAttribute('xadvance'), 10),\n                kerning: {},\n                texture: new core.Texture(texture.baseTexture, textureRect),\n\n            };\n        }\n\n        // parse kernings\n        const kernings = xml.getElementsByTagName('kerning');\n\n        for (let i = 0; i < kernings.length; i++)\n        {\n            const kerning = kernings[i];\n            const first = parseInt(kerning.getAttribute('first'), 10);\n            const second = parseInt(kerning.getAttribute('second'), 10);\n            const amount = parseInt(kerning.getAttribute('amount'), 10);\n\n            if (data.chars[second])\n            {\n                data.chars[second].kerning[first] = amount;\n            }\n        }\n\n        // I'm leaving this as a temporary fix so we can test the bitmap fonts in v3\n        // but it's very likely to change\n        BitmapText.fonts[data.font] = data;\n\n        return data;\n    }\n}\n\nBitmapText.fonts = {};\n"]}