{"version":3,"sources":["../../../src/extract/canvas/CanvasExtract.js"],"names":["core","TEMP_RECT","Rectangle","CanvasExtract","renderer","extract","image","target","Image","src","base64","canvas","toDataURL","context","resolution","frame","renderTexture","RenderTexture","generateTexture","baseTexture","_canvasRenderTarget","rootContext","width","height","canvasBuffer","CanvasRenderTarget","canvasData","getImageData","x","y","putImageData","pixels","data","destroy","CanvasRenderer","registerPlugin"],"mappings":"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","file":"CanvasExtract.js","sourcesContent":["import * as core from '../../core';\n\nconst TEMP_RECT = new core.Rectangle();\n\n/**\n * The extract manager provides functionality to export content from the renderers.\n *\n * An instance of this class is automatically created by default, and can be found at renderer.plugins.extract\n *\n * @class\n * @memberof PIXI.extract\n */\nexport default class CanvasExtract\n{\n    /**\n     * @param {PIXI.CanvasRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n        /**\n         * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture\n         *\n         * @member {PIXI.extract.CanvasExtract} extract\n         * @memberof PIXI.CanvasRenderer#\n         * @see PIXI.extract.CanvasExtract\n         */\n        renderer.extract = this;\n    }\n\n    /**\n     * Will return a HTML Image of the target\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {HTMLImageElement} HTML Image of the target\n     */\n    image(target)\n    {\n        const image = new Image();\n\n        image.src = this.base64(target);\n\n        return image;\n    }\n\n    /**\n     * Will return a a base64 encoded string of this target. It works by calling\n     *  `CanvasExtract.getCanvas` and then running toDataURL on that.\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {string} A base64 encoded string of the texture.\n     */\n    base64(target)\n    {\n        return this.canvas(target).toDataURL();\n    }\n\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.\n     */\n    canvas(target)\n    {\n        const renderer = this.renderer;\n        let context;\n        let resolution;\n        let frame;\n        let renderTexture;\n\n        if (target)\n        {\n            if (target instanceof core.RenderTexture)\n            {\n                renderTexture = target;\n            }\n            else\n            {\n                renderTexture = renderer.generateTexture(target);\n            }\n        }\n\n        if (renderTexture)\n        {\n            context = renderTexture.baseTexture._canvasRenderTarget.context;\n            resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;\n            frame = renderTexture.frame;\n        }\n        else\n        {\n            context = renderer.rootContext;\n\n            frame = TEMP_RECT;\n            frame.width = this.renderer.width;\n            frame.height = this.renderer.height;\n        }\n\n        const width = frame.width * resolution;\n        const height = frame.height * resolution;\n\n        const canvasBuffer = new core.CanvasRenderTarget(width, height);\n        const canvasData = context.getImageData(frame.x * resolution, frame.y * resolution, width, height);\n\n        canvasBuffer.context.putImageData(canvasData, 0, 0);\n\n        // send the canvas back..\n        return canvasBuffer.canvas;\n    }\n\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture\n     */\n    pixels(target)\n    {\n        const renderer = this.renderer;\n        let context;\n        let resolution;\n        let frame;\n        let renderTexture;\n\n        if (target)\n        {\n            if (target instanceof core.RenderTexture)\n            {\n                renderTexture = target;\n            }\n            else\n            {\n                renderTexture = renderer.generateTexture(target);\n            }\n        }\n\n        if (renderTexture)\n        {\n            context = renderTexture.baseTexture._canvasRenderTarget.context;\n            resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;\n            frame = renderTexture.frame;\n        }\n        else\n        {\n            context = renderer.rootContext;\n\n            frame = TEMP_RECT;\n            frame.width = renderer.width;\n            frame.height = renderer.height;\n        }\n\n        return context.getImageData(0, 0, frame.width * resolution, frame.height * resolution).data;\n    }\n\n    /**\n     * Destroys the extract\n     *\n     */\n    destroy()\n    {\n        this.renderer.extract = null;\n        this.renderer = null;\n    }\n}\n\ncore.CanvasRenderer.registerPlugin('extract', CanvasExtract);\n"]}