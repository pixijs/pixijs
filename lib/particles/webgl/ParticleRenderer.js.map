{"version":3,"sources":["../../../src/particles/webgl/ParticleRenderer.js"],"names":["core","ParticleRenderer","renderer","shader","indexBuffer","properties","tempMatrix","Matrix","CONTEXT_UID","onContextChange","gl","attribute","attributes","aVertexPosition","size","uploadFunction","uploadVertices","offset","aPositionCoord","uploadPosition","aRotation","uploadRotation","aTextureCoord","uploadUvs","aColor","uploadAlpha","start","bindShader","render","container","children","maxSize","_maxSize","batchSize","_batchSize","totalChildren","length","buffers","_glBuffers","generateBuffers","baseTexture","_texture","setBlendMode","utils","correctBlendMode","blendMode","premultipliedAlpha","m","worldTransform","copy","prepend","_activeRenderTarget","projectionMatrix","uniforms","toArray","uColor","premultiplyRgba","tintRgb","worldAlpha","uSampler","bindTexture","i","j","amount","buffer","uploadDynamic","_bufferToUpdate","uploadStatic","bindVao","vao","draw","TRIANGLES","dynamicPropertyFlags","_properties","push","startIndex","array","stride","w0","w1","h0","h1","sprite","texture","sx","scale","x","sy","y","trim","orig","anchor","width","height","spritePosition","position","spriteRotation","rotation","textureUvs","_uvs","x0","y0","x1","y1","x2","y2","x3","y3","spriteAlpha","alpha","destroy","deleteBuffer","indices","ObjectRenderer","WebGLRenderer","registerPlugin"],"mappings":"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","file":"ParticleRenderer.js","sourcesContent":["import * as core from '../../core';\nimport ParticleShader from './ParticleShader';\nimport ParticleBuffer from './ParticleBuffer';\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java\n */\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI\n */\nexport default class ParticleRenderer extends core.ObjectRenderer\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n        // so max number of particles is 65536 / 4 = 16384\n        // and max number of element in the index buffer is 16384 * 6 = 98304\n        // Creating a full index buffer, overhead is 98304 * 2 = 196Ko\n        // let numIndices = 98304;\n\n        /**\n         * The default shader that is used if a sprite doesn't have a more specific one.\n         *\n         * @member {PIXI.Shader}\n         */\n        this.shader = null;\n\n        this.indexBuffer = null;\n\n        this.properties = null;\n\n        this.tempMatrix = new core.Matrix();\n\n        this.CONTEXT_UID = 0;\n    }\n\n    /**\n     * When there is a WebGL context change\n     *\n     * @private\n     */\n    onContextChange()\n    {\n        const gl = this.renderer.gl;\n\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n        // setup default shader\n        this.shader = new ParticleShader(gl);\n\n        this.properties = [\n            // verticesData\n            {\n                attribute: this.shader.attributes.aVertexPosition,\n                size: 2,\n                uploadFunction: this.uploadVertices,\n                offset: 0,\n            },\n            // positionData\n            {\n                attribute: this.shader.attributes.aPositionCoord,\n                size: 2,\n                uploadFunction: this.uploadPosition,\n                offset: 0,\n            },\n            // rotationData\n            {\n                attribute: this.shader.attributes.aRotation,\n                size: 1,\n                uploadFunction: this.uploadRotation,\n                offset: 0,\n            },\n            // uvsData\n            {\n                attribute: this.shader.attributes.aTextureCoord,\n                size: 2,\n                uploadFunction: this.uploadUvs,\n                offset: 0,\n            },\n            // alphaData\n            {\n                attribute: this.shader.attributes.aColor,\n                size: 1,\n                uploadFunction: this.uploadAlpha,\n                offset: 0,\n            },\n        ];\n    }\n\n    /**\n     * Starts a new particle batch.\n     *\n     */\n    start()\n    {\n        this.renderer.bindShader(this.shader);\n    }\n\n    /**\n     * Renders the particle container object.\n     *\n     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n     */\n    render(container)\n    {\n        const children = container.children;\n        const maxSize = container._maxSize;\n        const batchSize = container._batchSize;\n        const renderer = this.renderer;\n        let totalChildren = children.length;\n\n        if (totalChildren === 0)\n        {\n            return;\n        }\n        else if (totalChildren > maxSize)\n        {\n            totalChildren = maxSize;\n        }\n\n        let buffers = container._glBuffers[renderer.CONTEXT_UID];\n\n        if (!buffers)\n        {\n            buffers = container._glBuffers[renderer.CONTEXT_UID] = this.generateBuffers(container);\n        }\n\n        const baseTexture = children[0]._texture.baseTexture;\n\n        // if the uvs have not updated then no point rendering just yet!\n        this.renderer.setBlendMode(core.utils.correctBlendMode(container.blendMode, baseTexture.premultipliedAlpha));\n\n        const gl = renderer.gl;\n\n        const m = container.worldTransform.copy(this.tempMatrix);\n\n        m.prepend(renderer._activeRenderTarget.projectionMatrix);\n\n        this.shader.uniforms.projectionMatrix = m.toArray(true);\n\n        this.shader.uniforms.uColor = core.utils.premultiplyRgba(container.tintRgb,\n            container.worldAlpha, this.shader.uniforms.uColor, baseTexture.premultipliedAlpha);\n\n        // make sure the texture is bound..\n        this.shader.uniforms.uSampler = renderer.bindTexture(baseTexture);\n\n        // now lets upload and render the buffers..\n        for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1)\n        {\n            let amount = (totalChildren - i);\n\n            if (amount > batchSize)\n            {\n                amount = batchSize;\n            }\n\n            const buffer = buffers[j];\n\n            // we always upload the dynamic\n            buffer.uploadDynamic(children, i, amount);\n\n            // we only upload the static content when we have to!\n            if (container._bufferToUpdate === j)\n            {\n                buffer.uploadStatic(children, i, amount);\n                container._bufferToUpdate = j + 1;\n            }\n\n            // bind the buffer\n            renderer.bindVao(buffer.vao);\n            buffer.vao.draw(gl.TRIANGLES, amount * 6);\n        }\n    }\n\n    /**\n     * Creates one particle buffer for each child in the container we want to render and updates internal properties\n     *\n     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n     * @return {PIXI.ParticleBuffer[]} The buffers\n     */\n    generateBuffers(container)\n    {\n        const gl = this.renderer.gl;\n        const buffers = [];\n        const size = container._maxSize;\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        for (let i = 0; i < size; i += batchSize)\n        {\n            buffers.push(new ParticleBuffer(gl, this.properties, dynamicPropertyFlags, batchSize));\n        }\n\n        return buffers;\n    }\n\n    /**\n     * Uploads the verticies.\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their vertices uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadVertices(children, startIndex, amount, array, stride, offset)\n    {\n        let w0 = 0;\n        let w1 = 0;\n        let h0 = 0;\n        let h1 = 0;\n\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const texture = sprite._texture;\n            const sx = sprite.scale.x;\n            const sy = sprite.scale.y;\n            const trim = texture.trim;\n            const orig = texture.orig;\n\n            if (trim)\n            {\n                // if the sprite is trimmed and is not a tilingsprite then we need to add the\n                // extra space before transforming the sprite coords..\n                w1 = trim.x - (sprite.anchor.x * orig.width);\n                w0 = w1 + trim.width;\n\n                h1 = trim.y - (sprite.anchor.y * orig.height);\n                h0 = h1 + trim.height;\n            }\n            else\n            {\n                w0 = (orig.width) * (1 - sprite.anchor.x);\n                w1 = (orig.width) * -sprite.anchor.x;\n\n                h0 = orig.height * (1 - sprite.anchor.y);\n                h1 = orig.height * -sprite.anchor.y;\n            }\n\n            array[offset] = w1 * sx;\n            array[offset + 1] = h1 * sy;\n\n            array[offset + stride] = w0 * sx;\n            array[offset + stride + 1] = h1 * sy;\n\n            array[offset + (stride * 2)] = w0 * sx;\n            array[offset + (stride * 2) + 1] = h0 * sy;\n\n            array[offset + (stride * 3)] = w1 * sx;\n            array[offset + (stride * 3) + 1] = h0 * sy;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their positions uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadPosition(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spritePosition = children[startIndex + i].position;\n\n            array[offset] = spritePosition.x;\n            array[offset + 1] = spritePosition.y;\n\n            array[offset + stride] = spritePosition.x;\n            array[offset + stride + 1] = spritePosition.y;\n\n            array[offset + (stride * 2)] = spritePosition.x;\n            array[offset + (stride * 2) + 1] = spritePosition.y;\n\n            array[offset + (stride * 3)] = spritePosition.x;\n            array[offset + (stride * 3) + 1] = spritePosition.y;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their rotation uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadRotation(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spriteRotation = children[startIndex + i].rotation;\n\n            array[offset] = spriteRotation;\n            array[offset + stride] = spriteRotation;\n            array[offset + (stride * 2)] = spriteRotation;\n            array[offset + (stride * 3)] = spriteRotation;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their rotation uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadUvs(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const textureUvs = children[startIndex + i]._texture._uvs;\n\n            if (textureUvs)\n            {\n                array[offset] = textureUvs.x0;\n                array[offset + 1] = textureUvs.y0;\n\n                array[offset + stride] = textureUvs.x1;\n                array[offset + stride + 1] = textureUvs.y1;\n\n                array[offset + (stride * 2)] = textureUvs.x2;\n                array[offset + (stride * 2) + 1] = textureUvs.y2;\n\n                array[offset + (stride * 3)] = textureUvs.x3;\n                array[offset + (stride * 3) + 1] = textureUvs.y3;\n\n                offset += stride * 4;\n            }\n            else\n            {\n                // TODO you know this can be easier!\n                array[offset] = 0;\n                array[offset + 1] = 0;\n\n                array[offset + stride] = 0;\n                array[offset + stride + 1] = 0;\n\n                array[offset + (stride * 2)] = 0;\n                array[offset + (stride * 2) + 1] = 0;\n\n                array[offset + (stride * 3)] = 0;\n                array[offset + (stride * 3) + 1] = 0;\n\n                offset += stride * 4;\n            }\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their rotation uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadAlpha(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spriteAlpha = children[startIndex + i].alpha;\n\n            array[offset] = spriteAlpha;\n            array[offset + stride] = spriteAlpha;\n            array[offset + (stride * 2)] = spriteAlpha;\n            array[offset + (stride * 3)] = spriteAlpha;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Destroys the ParticleRenderer.\n     *\n     */\n    destroy()\n    {\n        if (this.renderer.gl)\n        {\n            this.renderer.gl.deleteBuffer(this.indexBuffer);\n        }\n\n        super.destroy();\n\n        this.shader.destroy();\n\n        this.indices = null;\n        this.tempMatrix = null;\n    }\n\n}\n\ncore.WebGLRenderer.registerPlugin('particle', ParticleRenderer);\n"]}